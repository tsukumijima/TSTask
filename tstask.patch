diff -ruN a/TSTask/BonTsEngine/BonTsEngine.vcxproj b/TSTask/BonTsEngine/BonTsEngine.vcxproj
--- a/TSTask/BonTsEngine/BonTsEngine.vcxproj	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/BonTsEngine/BonTsEngine.vcxproj	2015-08-12 19:35:00.000000000 +0900
@@ -35,6 +35,8 @@
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
     </ClCompile>
+    <ClCompile Include="CardReader.cpp" />
+    <ClCompile Include="CasCard.cpp" />
     <ClCompile Include="EventInfo.cpp" />
     <ClCompile Include="Exception.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
@@ -52,6 +54,8 @@
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
     </ClCompile>
+    <ClCompile Include="Multi2Decoder.cpp" />
+    <ClCompile Include="Multi2DecoderSIMD.cpp" />
     <ClCompile Include="PATGenerator.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
@@ -68,6 +72,7 @@
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
     </ClCompile>
+    <ClCompile Include="TsDescrambler.cpp" />
     <ClCompile Include="TsDescriptor.cpp">
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
@@ -117,6 +122,8 @@
     <ClInclude Include="BonBaseClass.h" />
     <ClInclude Include="BonSrcDecoder.h" />
     <ClInclude Include="BonTsEngineConfig.h" />
+    <ClInclude Include="CardReader.h" />
+    <ClInclude Include="CasCard.h" />
     <ClInclude Include="Common.h" />
     <ClInclude Include="EventInfo.h" />
     <ClInclude Include="Exception.h" />
@@ -125,10 +132,13 @@
     <ClInclude Include="MediaData.h" />
     <ClInclude Include="MediaDecoder.h" />
     <ClInclude Include="MediaTee.h" />
+    <ClInclude Include="Multi2Decoder.h" />
+    <ClInclude Include="Multi2DecoderSIMD.h" />
     <ClInclude Include="PATGenerator.h" />
     <ClInclude Include="stdafx.h" />
     <ClInclude Include="StdUtil.h" />
     <ClInclude Include="TsAnalyzer.h" />
+    <ClInclude Include="TsDescrambler.h" />
     <ClInclude Include="TsDescriptor.h" />
     <ClInclude Include="TsEncode.h" />
     <ClInclude Include="TsGrabber.h" />
diff -ruN a/TSTask/BonTsEngine/BonTsEngine.vcxproj.filters b/TSTask/BonTsEngine/BonTsEngine.vcxproj.filters
--- a/TSTask/BonTsEngine/BonTsEngine.vcxproj.filters	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/BonTsEngine/BonTsEngine.vcxproj.filters	2015-08-12 19:35:00.000000000 +0900
@@ -86,6 +86,21 @@
     <ClCompile Include="TsRecorder.cpp">
       <Filter>繧ｽ繝ｼ繧ｹ 繝輔ぃ繧､繝ｫ</Filter>
     </ClCompile>
+    <ClCompile Include="TsDescrambler.cpp">
+      <Filter>繧ｽ繝ｼ繧ｹ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClCompile>
+    <ClCompile Include="CardReader.cpp">
+      <Filter>繧ｽ繝ｼ繧ｹ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClCompile>
+    <ClCompile Include="CasCard.cpp">
+      <Filter>繧ｽ繝ｼ繧ｹ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClCompile>
+    <ClCompile Include="Multi2Decoder.cpp">
+      <Filter>繧ｽ繝ｼ繧ｹ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClCompile>
+    <ClCompile Include="Multi2DecoderSIMD.cpp">
+      <Filter>繧ｽ繝ｼ繧ｹ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Bitstream.h">
@@ -178,5 +193,20 @@
     <ClInclude Include="TsRecorder.h">
       <Filter>繝倥ャ繝繝ｼ 繝輔ぃ繧､繝ｫ</Filter>
     </ClInclude>
+    <ClInclude Include="Multi2DecoderSIMD.h">
+      <Filter>繝倥ャ繝繝ｼ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClInclude>
+    <ClInclude Include="TsDescrambler.h">
+      <Filter>繝倥ャ繝繝ｼ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClInclude>
+    <ClInclude Include="Multi2Decoder.h">
+      <Filter>繝倥ャ繝繝ｼ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClInclude>
+    <ClInclude Include="CardReader.h">
+      <Filter>繝倥ャ繝繝ｼ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClInclude>
+    <ClInclude Include="CasCard.h">
+      <Filter>繝倥ャ繝繝ｼ 繝輔ぃ繧､繝ｫ</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ 繝輔ぃ繧､繝ｫ譛ｫ蟆ｾ縺ｫ謾ｹ陦後′縺ゅｊ縺ｾ縺帙ｓ
diff -ruN a/TSTask/BonTsEngine/CardReader.cpp b/TSTask/BonTsEngine/CardReader.cpp
--- a/TSTask/BonTsEngine/CardReader.cpp	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/CardReader.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,1131 @@
+#include "stdafx.h"
+#include "CardReader.h"
+#include "StdUtil.h"
+
+#ifdef _DEBUG
+#undef THIS_FILE
+static char THIS_FILE[]=__FILE__;
+#define new DEBUG_NEW
+#endif
+
+
+
+
+CCardReader::CCardReader()
+{
+}
+
+
+CCardReader::~CCardReader()
+{
+}
+
+
+LPCTSTR CCardReader::EnumReader(int Index) const
+{
+	if (Index != 0)
+		return NULL;
+	return GetReaderName();
+}
+
+
+CCardReader *CCardReader::CreateCardReader(ReaderType Type)
+{
+	CCardReader *pReader;
+
+	switch (Type) {
+	case READER_SCARD:
+		pReader = new CSCardReader;
+		break;
+
+#ifdef CARDREADER_SCARD_DYNAMIC_SUPPORT
+	case READER_SCARD_DYNAMIC:
+		pReader = new CDynamicSCardReader;
+		break;
+#endif
+
+#ifdef CARDREADER_BONCASCLIENT_SUPPORT
+	case READER_BONCASCLIENT:
+		pReader = new CBonCasClientCardReader;
+		break;
+#endif
+
+	default:
+		return NULL;
+	}
+
+	pReader->m_ReaderType = Type;
+
+	return pReader;
+}
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// 標準スマートカードリーダー
+//
+///////////////////////////////////////////////////////////////////////////////
+
+
+#pragma comment(lib, "WinScard.lib")
+
+
+static LPCTSTR GetSCardErrorText(LONG Code)
+{
+	switch (Code) {
+	case ERROR_BROKEN_PIPE:
+		return TEXT("ERROR_BROKEN_PIPE: The client attempted a smart card operation in a remote session.");
+	case SCARD_F_INTERNAL_ERROR:
+		return TEXT("SCARD_F_INTERNAL_ERROR: An internal consistency check failed.");
+	case SCARD_E_CANCELLED:
+		return TEXT("SCARD_E_CANCELLED: The action was cancelled by an SCardCancel request.");
+	case SCARD_E_INVALID_HANDLE:
+		return TEXT("SCARD_E_INVALID_HANDLE: The supplied handle was invalid.");
+	case SCARD_E_INVALID_PARAMETER:
+		return TEXT("SCARD_E_INVALID_PARAMETER: One or more of the supplied parameters could not be properly interpreted.");
+	case SCARD_E_INVALID_TARGET:
+		return TEXT("SCARD_E_INVALID_TARGET: Registry startup information is missing or invalid.");
+	case SCARD_E_NO_MEMORY:
+		return TEXT("SCARD_E_NO_MEMORY: Not enough memory available to complete this command.");
+	case SCARD_F_WAITED_TOO_LONG:
+		return TEXT("SCARD_F_WAITED_TOO_LONG: An internal consistency timer has expired.");
+	case SCARD_E_INSUFFICIENT_BUFFER:
+		return TEXT("SCARD_E_INSUFFICIENT_BUFFER: The data buffer to receive returned data is too small for the returned data.");
+	case SCARD_E_UNKNOWN_READER:
+		return TEXT("SCARD_E_UNKNOWN_READER: The specified reader name is not recognized.");
+	case SCARD_E_TIMEOUT:
+		return TEXT("SCARD_E_TIMEOUT: The user-specified timeout value has expired.");
+	case SCARD_E_SHARING_VIOLATION:
+		return TEXT("SCARD_E_SHARING_VIOLATION: The smart card cannot be accessed because of other connections outstanding.");
+	case SCARD_E_NO_SMARTCARD:
+		return TEXT("SCARD_E_NO_SMARTCARD: The operation requires a Smart Card, but no Smart Card is currently in the device.");
+	case SCARD_E_UNKNOWN_CARD:
+		return TEXT("SCARD_E_UNKNOWN_CARD: The specified smart card name is not recognized.");
+	case SCARD_E_CANT_DISPOSE:
+		return TEXT("SCARD_E_CANT_DISPOSE: The system could not dispose of the media in the requested manner.");
+	case SCARD_E_PROTO_MISMATCH:
+		return TEXT("SCARD_E_PROTO_MISMATCH: The requested protocols are incompatible with the protocol currently in use with the smart card.");
+	case SCARD_E_NOT_READY:
+		return TEXT("SCARD_E_NOT_READY: The reader or smart card is not ready to accept commands.");
+	case SCARD_E_INVALID_VALUE:
+		return TEXT("SCARD_E_INVALID_VALUE: One or more of the supplied parameters values could not be properly interpreted.");
+	case SCARD_E_SYSTEM_CANCELLED:
+		return TEXT("SCARD_E_SYSTEM_CANCELLED: The action was cancelled by the system, presumably to log off or shut down.");
+	case SCARD_F_COMM_ERROR:
+		return TEXT("SCARD_F_COMM_ERROR: An internal communications error has been detected.");
+	case SCARD_F_UNKNOWN_ERROR:
+		return TEXT("SCARD_F_UNKNOWN_ERROR: An internal error has been detected, but the source is unknown.");
+	case SCARD_E_INVALID_ATR:
+		return TEXT("SCARD_E_INVALID_ATR: An ATR obtained from the registry is not a valid ATR string.");
+	case SCARD_E_NOT_TRANSACTED:
+		return TEXT("SCARD_E_NOT_TRANSACTED: An attempt was made to end a non-existent transaction.");
+	case SCARD_E_READER_UNAVAILABLE:
+		return TEXT("SCARD_E_READER_UNAVAILABLE: The specified reader is not currently available for use.");
+	case SCARD_P_SHUTDOWN:
+		return TEXT("SCARD_P_SHUTDOWN: The operation has been aborted to allow the server application to exit.");
+	case SCARD_E_PCI_TOO_SMALL:
+		return TEXT("SCARD_E_PCI_TOO_SMALL: The PCI Receive buffer was too small.");
+	case SCARD_E_READER_UNSUPPORTED:
+		return TEXT("SCARD_E_READER_UNSUPPORTED: The reader driver does not meet minimal requirements for support.");
+	case SCARD_E_DUPLICATE_READER:
+		return TEXT("SCARD_E_DUPLICATE_READER: The reader driver did not produce a unique reader name.");
+	case SCARD_E_CARD_UNSUPPORTED:
+		return TEXT("SCARD_E_CARD_UNSUPPORTED: The smart card does not meet minimal requirements for support.");
+	case SCARD_E_NO_SERVICE:
+		return TEXT("SCARD_E_NO_SERVICE: The Smart card resource manager is not running.");
+	case SCARD_E_SERVICE_STOPPED:
+		return TEXT("SCARD_E_SERVICE_STOPPED: The Smart card resource manager has shut down.");
+	case SCARD_E_UNEXPECTED:
+		return TEXT("SCARD_E_UNEXPECTED: An unexpected card error has occurred.");
+	case SCARD_E_ICC_INSTALLATION:
+		return TEXT("SCARD_E_ICC_INSTALLATION: No Primary Provider can be found for the smart card.");
+	case SCARD_E_ICC_CREATEORDER:
+		return TEXT("SCARD_E_ICC_CREATEORDER: The requested order of object creation is not supported.");
+	case SCARD_E_UNSUPPORTED_FEATURE:
+		return TEXT("SCARD_E_UNSUPPORTED_FEATURE: This smart card does not support the requested feature.");
+	case SCARD_E_DIR_NOT_FOUND:
+		return TEXT("SCARD_E_DIR_NOT_FOUND: The identified directory does not exist in the smart card.");
+	case SCARD_E_FILE_NOT_FOUND:
+		return TEXT("SCARD_E_FILE_NOT_FOUND: The identified file does not exist in the smart card.");
+	case SCARD_E_NO_DIR:
+		return TEXT("SCARD_E_NO_DIR: The supplied path does not represent a smart card directory.");
+	case SCARD_E_NO_FILE:
+		return TEXT("SCARD_E_NO_FILE: The supplied path does not represent a smart card file.");
+	case SCARD_E_NO_ACCESS:
+		return TEXT("SCARD_E_NO_ACCESS: Access is denied to this file.");
+	case SCARD_E_WRITE_TOO_MANY:
+		return TEXT("SCARD_E_WRITE_TOO_MANY: The smartcard does not have enough memory to store the information.");
+	case SCARD_E_BAD_SEEK:
+		return TEXT("SCARD_E_BAD_SEEK: There was an error trying to set the smart card file object pointer.");
+	case SCARD_E_INVALID_CHV:
+		return TEXT("SCARD_E_INVALID_CHV: The supplied PIN is incorrect.");
+	case SCARD_E_UNKNOWN_RES_MNG:
+		return TEXT("SCARD_E_UNKNOWN_RES_MNG: An unrecognized error code was returned from a layered component.");
+	case SCARD_E_NO_SUCH_CERTIFICATE:
+		return TEXT("SCARD_E_NO_SUCH_CERTIFICATE: The requested certificate does not exist.");
+	case SCARD_E_CERTIFICATE_UNAVAILABLE:
+		return TEXT("SCARD_E_CERTIFICATE_UNAVAILABLE: The requested certificate could not be obtained.");
+	case SCARD_E_NO_READERS_AVAILABLE:
+		return TEXT("SCARD_E_NO_READERS_AVAILABLE: Cannot find a smart card reader.");
+	case SCARD_E_COMM_DATA_LOST:
+		return TEXT("SCARD_E_COMM_DATA_LOST: A communications error with the smart card has been detected.  Retry the operation.");
+	case SCARD_E_NO_KEY_CONTAINER:
+		return TEXT("SCARD_E_NO_KEY_CONTAINER: The requested key container does not exist on the smart card.");
+	case SCARD_E_SERVER_TOO_BUSY:
+		return TEXT("SCARD_E_SERVER_TOO_BUSY: The Smart card resource manager is too busy to complete this operation.");
+	case SCARD_W_UNSUPPORTED_CARD:
+		return TEXT("SCARD_W_UNSUPPORTED_CARD: The reader cannot communicate with the smart card, due to ATR configuration conflicts.");
+	case SCARD_W_UNRESPONSIVE_CARD:
+		return TEXT("SCARD_W_UNRESPONSIVE_CARD: The smart card is not responding to a reset.");
+	case SCARD_W_UNPOWERED_CARD:
+		return TEXT("SCARD_W_UNPOWERED_CARD: Power has been removed from the smart card, so that further communication is not possible.");
+	case SCARD_W_RESET_CARD:
+		return TEXT("SCARD_W_RESET_CARD: The smart card has been reset, so any shared state information is invalid.");
+	case SCARD_W_REMOVED_CARD:
+		return TEXT("SCARD_W_REMOVED_CARD: The smart card has been removed, so that further communication is not possible.");
+	case SCARD_W_SECURITY_VIOLATION:
+		return TEXT("SCARD_W_SECURITY_VIOLATION: Access was denied because of a security violation.");
+	case SCARD_W_WRONG_CHV:
+		return TEXT("SCARD_W_WRONG_CHV: The card cannot be accessed because the wrong PIN was presented.");
+	case SCARD_W_CHV_BLOCKED:
+		return TEXT("SCARD_W_CHV_BLOCKED: The card cannot be accessed because the maximum number of PIN entry attempts has been reached.");
+	case SCARD_W_EOF:
+		return TEXT("SCARD_W_EOF: The end of the smart card file has been reached.");
+	case SCARD_W_CANCELLED_BY_USER:
+		return TEXT("SCARD_W_CANCELLED_BY_USER: The action was cancelled by the user.");
+	case SCARD_W_CARD_NOT_AUTHENTICATED:
+		return TEXT("SCARD_W_CARD_NOT_AUTHENTICATED: No PIN was presented to the smart card.");
+	case SCARD_W_CACHE_ITEM_NOT_FOUND:
+		return TEXT("SCARD_W_CACHE_ITEM_NOT_FOUND: The requested item could not be found in the cache.");
+	case SCARD_W_CACHE_ITEM_STALE:
+		return TEXT("SCARD_W_CACHE_ITEM_STALE: The requested cache item is too old and was deleted from the cache.");
+	case SCARD_W_CACHE_ITEM_TOO_BIG:
+		return TEXT("SCARD_W_CACHE_ITEM_TOO_BIG: The new cache item exceeds the maximum per-item size defined for the cache.");
+	}
+	return NULL;
+}
+
+static DWORD GetSCardErrorMessage(LONG Code,LPTSTR pszMessage,DWORD MaxLength)
+{
+	LPCTSTR pszText = GetSCardErrorText(Code);
+	DWORD Length = 0;
+	if (pszText != NULL) {
+		Length = (DWORD)(::StrStr(pszText, TEXT(" ")) - pszText + 1);
+		if (Length > MaxLength)
+			Length = MaxLength;
+		::lstrcpyn(pszMessage, pszText, Length + 1);
+	}
+	Length = ::FormatMessage(
+		FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL,
+		Code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+		pszMessage + Length, MaxLength - Length, NULL);
+	if (Length == 0) {
+		if (pszText != NULL)
+			::lstrcpyn(pszMessage, pszText, MaxLength);
+		else
+			pszMessage[0] = '\0';
+	}
+	return Length;
+}
+
+static bool CheckReaderList(LPCTSTR pReaderList, DWORD Length)
+{
+	if (Length < 2)
+		return false;
+	return pReaderList[Length - 2] == _T('\0')
+		&& pReaderList[Length - 1] == _T('\0');
+}
+
+
+// サービスAPI用
+#pragma comment(lib, "advapi32.lib")
+
+// スマートカードサービスが有効か調べる
+enum SCardCheckResult {
+	SCARD_CHECK_ENABLED,
+	SCARD_CHECK_DISABLED,
+	SCARD_CHECK_ERR_SERVICE_NOT_FOUND,
+	SCARD_CHECK_ERR_OPEN_MANAGER,
+	SCARD_CHECK_ERR_OPEN_SERVICE,
+	SCARD_CHECK_ERR_QUERY_CONFIG
+};
+
+static SCardCheckResult CheckSmartCardService()
+{
+	SCardCheckResult Result;
+
+	SC_HANDLE hManager = ::OpenSCManager(NULL, NULL, GENERIC_READ);
+	if (hManager == NULL)
+		return SCARD_CHECK_ERR_OPEN_MANAGER;
+
+	TCHAR szName[256];
+	DWORD Length = _countof(szName);
+	if (!::GetServiceKeyName(hManager, TEXT("Smart Card"), szName, &Length))
+		::lstrcpy(szName, TEXT("SCardSvr"));
+
+	SC_HANDLE hService = ::OpenService(hManager, szName, SERVICE_QUERY_CONFIG);
+	if (hService == NULL) {
+		if (::GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST)
+			Result = SCARD_CHECK_ERR_SERVICE_NOT_FOUND;
+		else
+			Result = SCARD_CHECK_ERR_OPEN_SERVICE;
+		::CloseServiceHandle(hManager);
+		return Result;
+	}
+
+	Result = SCARD_CHECK_ERR_QUERY_CONFIG;
+	DWORD Size = 0;
+	::QueryServiceConfig(hService, NULL, 0, &Size);
+	if (Size > 0) {
+		BYTE *pBuffer = new BYTE[Size];
+		QUERY_SERVICE_CONFIG *pConfig = (QUERY_SERVICE_CONFIG*)pBuffer;
+
+		if (::QueryServiceConfig(hService, pConfig, Size, &Size)) {
+			if (pConfig->dwStartType == SERVICE_DISABLED)
+				Result = SCARD_CHECK_DISABLED;
+			else
+				Result = SCARD_CHECK_ENABLED;
+		}
+		delete [] pBuffer;
+	}
+
+	::CloseServiceHandle(hService);
+	::CloseServiceHandle(hManager);
+
+	return Result;
+}
+
+
+CSCardReader::CSCardReader()
+	: m_hSCard(0)
+	, m_bIsEstablish(false)
+	, m_pReaderList(NULL)
+	, m_NumReaders(0)
+	, m_pszReaderName(NULL)
+{
+	TRACE(TEXT("SCardEstablishContext\n"));
+	if (::SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &m_SCardContext) == SCARD_S_SUCCESS) {
+		m_bIsEstablish = true;
+
+		// カードリーダを列挙する
+		DWORD dwBuffLength = SCARD_AUTOALLOCATE;
+
+		TRACE(TEXT("SCardListReaders\n"));
+		if (::SCardListReaders(m_SCardContext, NULL,
+				reinterpret_cast<LPTSTR>(&m_pReaderList), &dwBuffLength) == SCARD_S_SUCCESS) {
+			if (CheckReaderList(m_pReaderList, dwBuffLength)) {
+				LPCTSTR p = m_pReaderList;
+				while (*p) {
+					TRACE(TEXT(" Reader%d : %s\n"), m_NumReaders, p);
+					m_NumReaders++;
+					p += ::lstrlen(p) + 1;
+				}
+			} else {
+				::SCardFreeMemory(m_SCardContext, m_pReaderList);
+				m_pReaderList = NULL;
+			}
+		}
+	}
+}
+
+
+CSCardReader::~CSCardReader()
+{
+	Close();
+
+	if (m_bIsEstablish) {
+		if (m_pReaderList)
+			::SCardFreeMemory(m_SCardContext, m_pReaderList);
+
+		TRACE(TEXT("SCardReleaseContext\n"));
+		::SCardReleaseContext(m_SCardContext);
+	}
+}
+
+
+bool CSCardReader::Open(LPCTSTR pszReader)
+{
+	if (!m_bIsEstablish) {
+		SetError(TEXT("コンテキストを確立できません。"),
+				 TEXT("Smart Card サービスが有効であるか確認してください。"));
+		return false;
+	}
+
+	// 一旦クローズする
+	Close();
+
+	if (pszReader) {
+		// 指定されたカードリーダに対してオープンを試みる
+		TRACE(TEXT("Open card reader \"%s\"\n"), pszReader);
+
+		LONG Result;
+
+		SCARD_READERSTATE ReaderState;
+		::ZeroMemory(&ReaderState, sizeof(ReaderState));
+		ReaderState.szReader = pszReader;
+
+		TRACE(TEXT("SCardGetStatusChange\n"));
+		Result = ::SCardGetStatusChange(m_SCardContext, 0, &ReaderState, 1);
+		if (Result != SCARD_S_SUCCESS) {
+			TCHAR szMessage[256];
+			GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+			SetError(TEXT("カードリーダの状態を取得できません。"), NULL, szMessage);
+			return false;
+		}
+
+		if (!(ReaderState.dwEventState & SCARD_STATE_PRESENT)) {
+			TCHAR szMessage[256];
+			StdUtil::snprintf(szMessage, _countof(szMessage),
+							  TEXT("カードリーダが利用できません。(State %08x)"),
+							  ReaderState.dwEventState);
+			SetError(szMessage);
+			return false;
+		}
+
+		DWORD dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
+
+		TRACE(TEXT("SCardConnect\n"));
+		Result = ::SCardConnect(m_SCardContext, pszReader, SCARD_SHARE_SHARED, SCARD_PROTOCOL_T1, &m_hSCard, &dwActiveProtocol);
+		if (Result != SCARD_S_SUCCESS) {
+			TCHAR szMessage[256];
+			GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+			SetError(TEXT("カードリーダに接続できません。"), NULL, szMessage);
+			return false;
+		}
+
+		if (dwActiveProtocol != SCARD_PROTOCOL_T1) {
+			Close();
+			SetError(TEXT("アクティブプロトコルが不正です。"));
+			return false;
+		}
+
+		LPTSTR pszReaderName;
+		BYTE Atr[32];
+		DWORD dwReaderLen = SCARD_AUTOALLOCATE, dwState, dwProtocol, dwAtrLen = sizeof(Atr);
+		TRACE(TEXT("SCardStatus\n"));
+		Result = ::SCardStatus(m_hSCard, reinterpret_cast<LPTSTR>(&pszReaderName), &dwReaderLen, &dwState, &dwProtocol, Atr, &dwAtrLen);
+		if (Result != SCARD_S_SUCCESS) {
+			Close();
+			TCHAR szMessage[256];
+			GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+			SetError(TEXT("カードの状態を取得できません。"), NULL, szMessage);
+			return false;
+		}
+		TCHAR szAtr[sizeof(Atr) * 3 + 1];
+		for (DWORD i = 0; i < dwAtrLen; i++)
+			::wsprintf(&szAtr[i * 2], TEXT("%02x "), Atr[i]);
+		TRACE(TEXT("\nName : %s\nState : %08x\nProtocol : %u\nATR size : %u\nATR : %s\n"),
+			  pszReaderName, dwState, dwProtocol, dwAtrLen, dwAtrLen ? szAtr : TEXT("n/a"));
+		::SCardFreeMemory(m_SCardContext, pszReaderName);
+
+		m_pszReaderName = StdUtil::strdup(pszReader);
+	} else {
+		// 全てのカードリーダに対してオープンを試みる
+		if (m_pReaderList == NULL) {
+			SetError(TEXT("カードリーダが見付かりません。"));
+			return false;
+		}
+
+		LPCTSTR p = m_pReaderList;
+		while (*p) {
+			if (Open(p))
+				return true;
+			p += ::lstrlen(p) + 1;
+		}
+		return false;
+	}
+
+	ClearError();
+
+	return true;
+}
+
+
+void CSCardReader::Close()
+{
+	if (m_hSCard) {
+		TRACE(TEXT("SCardDisconnect\n"));
+		::SCardDisconnect(m_hSCard, SCARD_LEAVE_CARD);
+		m_hSCard = 0;
+	}
+
+	if (m_pszReaderName) {
+		delete [] m_pszReaderName;
+		m_pszReaderName = NULL;
+	}
+}
+
+
+LPCTSTR CSCardReader::GetReaderName() const
+{
+	return m_pszReaderName;
+}
+
+
+int CSCardReader::NumReaders() const
+{
+	return m_NumReaders;
+}
+
+
+LPCTSTR CSCardReader::EnumReader(int Index) const
+{
+	if (Index < 0 || Index >= m_NumReaders)
+		return NULL;
+	LPCTSTR p = m_pReaderList;
+	for (int i = 0; i < Index; i++)
+		p += ::lstrlen(p) + 1;
+	return p;
+}
+
+
+bool CSCardReader::IsAvailable()
+{
+	return m_bIsEstablish
+		&& ::SCardIsValidContext(m_SCardContext) == SCARD_S_SUCCESS
+		&& m_NumReaders > 0;
+}
+
+
+bool CSCardReader::IsReaderAvailable(LPCTSTR pszReader)
+{
+	if (!m_bIsEstablish || pszReader == NULL)
+		return false;
+
+	LONG Result;
+
+	SCARD_READERSTATE ReaderState;
+	::ZeroMemory(&ReaderState, sizeof(ReaderState));
+	ReaderState.szReader = pszReader;
+
+	Result = ::SCardGetStatusChange(m_SCardContext, 0, &ReaderState, 1);
+	if (Result != SCARD_S_SUCCESS)
+		return false;
+
+	if (!(ReaderState.dwEventState & SCARD_STATE_PRESENT))
+		return false;
+
+	return true;
+}
+
+
+bool CSCardReader::CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength)
+{
+	bool bAvailable = false;
+
+	switch (CheckSmartCardService()) {
+	case SCARD_CHECK_ENABLED:
+		if (pszMessage)
+			::lstrcpyn(pszMessage, TEXT("Smart Card サービスは有効です。"), MaxLength);
+		bAvailable = true;
+		break;
+
+	case SCARD_CHECK_DISABLED:
+		if (pszMessage)
+			::lstrcpyn(pszMessage, TEXT("Smart Card サービスが無効になっています。"), MaxLength);
+		break;
+
+	case SCARD_CHECK_ERR_SERVICE_NOT_FOUND:
+		if (pszMessage)
+			::lstrcpyn(pszMessage, TEXT("Smart Card サービスがインストールされていません。"), MaxLength);
+		break;
+
+	default:
+		return false;
+	}
+
+	*pbAvailable = bAvailable;
+
+	return true;
+}
+
+
+bool CSCardReader::Transmit(const void *pSendData, DWORD SendSize, void *pRecvData, DWORD *pRecvSize)
+{
+	if (!m_hSCard) {
+		SetError(TEXT("カードリーダが開かれていません。"));
+		return false;
+	}
+
+	LONG Result = ::SCardTransmit(m_hSCard, SCARD_PCI_T1,
+		static_cast<LPCBYTE>(pSendData), SendSize, NULL, static_cast<LPBYTE>(pRecvData), pRecvSize);
+
+	if (Result != SCARD_S_SUCCESS) {
+		TCHAR szMessage[256];
+		GetSCardErrorMessage(Result,szMessage, _countof(szMessage));
+		SetError(TEXT("コマンド送信エラーです。"), NULL, szMessage);
+		return false;
+	}
+
+	ClearError();
+
+	return true;
+}
+
+
+
+
+#ifdef CARDREADER_SCARD_DYNAMIC_SUPPORT
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// winscard.dll互換カードリーダー(動的リンク)
+//
+///////////////////////////////////////////////////////////////////////////////
+
+
+#ifdef UNICODE
+#define FUNC_NAME(symbol) symbol "W"
+#else
+#define FUNC_NAME(symbol) symbol "A"
+#endif
+
+template<typename T> bool GetLibraryFunc(HMODULE hLib, T &Func, const char *pSymbol)
+{
+	return (Func = reinterpret_cast<T>(::GetProcAddress(hLib, pSymbol))) != NULL;
+}
+
+
+CDynamicSCardReader::CDynamicSCardReader()
+	: m_hLib(NULL)
+	, m_hSCard(0)
+	, m_pReaderList(NULL)
+	, m_pszReaderName(NULL)
+
+	, m_pSCardReleaseContext(NULL)
+	, m_pSCardConnect(NULL)
+	, m_pSCardDisconnect(NULL)
+	, m_pSCardTransmit(NULL)
+{
+}
+
+
+CDynamicSCardReader::~CDynamicSCardReader()
+{
+	Unload();
+}
+
+
+bool CDynamicSCardReader::Load(LPCTSTR pszFileName)
+{
+	m_hLib = ::LoadLibrary(pszFileName);
+	if (m_hLib == NULL) {
+		SetError(TEXT("ライブラリをロードできません。"));
+		return false;
+	}
+
+	typedef LONG (WINAPI *SCardEstablishContextFunc)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
+	typedef LONG (WINAPI *SCardListReadersFunc)(SCARDCONTEXT, LPCTSTR, LPTSTR, LPDWORD);
+	SCardEstablishContextFunc pEstablishContext;
+	SCardListReadersFunc pListReaders;
+
+	if (!GetLibraryFunc(m_hLib, pEstablishContext, "SCardEstablishContext")
+	 || !GetLibraryFunc(m_hLib, pListReaders, FUNC_NAME("SCardListReaders"))
+	 || !GetLibraryFunc(m_hLib, m_pSCardReleaseContext, "SCardReleaseContext")
+	 || !GetLibraryFunc(m_hLib, m_pSCardConnect, FUNC_NAME("SCardConnect"))
+	 || !GetLibraryFunc(m_hLib, m_pSCardDisconnect, "SCardDisconnect")
+	 || !GetLibraryFunc(m_hLib, m_pSCardTransmit, "SCardTransmit")) {
+		::FreeLibrary(m_hLib);
+		m_hLib = NULL;
+		SetError(TEXT("関数のアドレスを取得できません。"));
+		return false;
+	}
+
+	if (pEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &m_SCardContext) != SCARD_S_SUCCESS) {
+		::FreeLibrary(m_hLib);
+		m_hLib = NULL;
+		SetError(TEXT("コンテキストを確立できません。"));
+		return false;
+	}
+
+	// カードリーダを列挙する
+	DWORD dwBuffLength = 0;
+
+	if (pListReaders(m_SCardContext, NULL, NULL, &dwBuffLength) == SCARD_S_SUCCESS) {
+		m_pReaderList = new TCHAR[dwBuffLength];
+		if (pListReaders(m_SCardContext, NULL, m_pReaderList, &dwBuffLength) == SCARD_S_SUCCESS) {
+			if (!CheckReaderList(m_pReaderList, dwBuffLength)) {
+				Unload();
+				SetError(TEXT("カードリーダのリストが不正です。"));
+				return false;
+			}
+		} else {
+			delete [] m_pReaderList;
+			m_pReaderList = NULL;
+		}
+	}
+
+	return true;
+}
+
+
+void CDynamicSCardReader::Unload()
+{
+	Close();
+
+	if (m_hLib) {
+		m_pSCardReleaseContext(m_SCardContext);
+
+		::FreeLibrary(m_hLib);
+		m_hLib = NULL;
+	}
+
+	if (m_pReaderList) {
+		delete [] m_pReaderList;
+		m_pReaderList = NULL;
+	}
+}
+
+
+// "ファイル名|リーダ名" の形式で指定する
+bool CDynamicSCardReader::Open(LPCTSTR pszReader)
+{
+	if (pszReader == NULL) {
+		SetError(TEXT("ファイル名が指定されていません。"));
+		return false;
+	}
+
+	LPCTSTR pszReaderName = ::StrChr(pszReader, _T('|'));
+	if (pszReaderName != NULL) {
+		pszReaderName++;
+		if (!*pszReaderName)
+			pszReaderName = NULL;
+	}
+	TCHAR szFileName[MAX_PATH];
+	if (pszReaderName != NULL) {
+		size_t FileNameLength = pszReaderName - pszReader;
+		if (FileNameLength > _countof(szFileName)) {
+			SetError(TEXT("ファイル名が長過ぎます。"));
+			return false;
+		}
+		::lstrcpyn(szFileName, pszReader, (int)FileNameLength);
+	} else {
+		if (::lstrlen(pszReader) >= _countof(szFileName)) {
+			SetError(TEXT("ファイル名が長過ぎます。"));
+			return false;
+		}
+		::lstrcpy(szFileName, pszReader);
+	}
+	if (m_hLib == NULL) {
+		if (!Load(szFileName))
+			return false;
+	} else {
+		// 一旦クローズする
+		Close();
+	}
+
+	if (pszReaderName) {
+		// 指定されたカードリーダに対してオープンを試みる
+		LONG Result;
+		DWORD dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
+
+		Result=m_pSCardConnect(m_SCardContext, pszReaderName, SCARD_SHARE_SHARED, SCARD_PROTOCOL_T1, &m_hSCard, &dwActiveProtocol);
+		if (Result != SCARD_S_SUCCESS) {
+			TCHAR szMessage[256];
+			GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+			SetError(TEXT("カードリーダに接続できません。"), NULL, szMessage);
+			return false;
+		}
+
+		if (dwActiveProtocol != SCARD_PROTOCOL_T1) {
+			Close();
+			SetError(TEXT("アクティブプロトコルが不正です。"));
+			return false;
+		}
+
+		m_pszReaderName = StdUtil::strdup(pszReader);
+	} else {
+		// 全てのカードリーダに対してオープンを試みる
+		if (m_pReaderList == NULL || m_pReaderList[0] == _T('\0')) {
+			SetError(TEXT("カードリーダが見付かりません。"));
+			return false;
+		}
+
+		LPCTSTR p = m_pReaderList;
+		while (*p) {
+			TCHAR szReader[MAX_PATH + 256];
+
+			StdUtil::snprintf(szReader, _countof(szReader), TEXT("%s|%s"), szFileName, p);
+			if (Open(szReader))
+				return true;
+			p += ::lstrlen(p) + 1;
+		}
+		return false;
+	}
+
+	ClearError();
+
+	return true;
+}
+
+
+void CDynamicSCardReader::Close()
+{
+	if (m_hSCard) {
+		m_pSCardDisconnect(m_hSCard, SCARD_LEAVE_CARD);
+		m_hSCard = 0;
+	}
+
+	if (m_pszReaderName) {
+		delete [] m_pszReaderName;
+		m_pszReaderName = NULL;
+	}
+}
+
+
+LPCTSTR CDynamicSCardReader::GetReaderName() const
+{
+	return m_pszReaderName;
+}
+
+
+int CDynamicSCardReader::NumReaders() const
+{
+	if (!m_pReaderList)
+		return 0;
+	LPCTSTR p = m_pReaderList;
+	int i;
+	for (i = 0; *p; i++) {
+		p += ::lstrlen(p) + 1;
+	}
+	return i;
+}
+
+
+LPCTSTR CDynamicSCardReader::EnumReader(int Index) const
+{
+	if (!m_pReaderList)
+		return NULL;
+	LPCTSTR p = m_pReaderList;
+	for (int i = 0; i < Index; i++) {
+		if (!*p)
+			return NULL;
+		p += ::lstrlen(p) + 1;
+	}
+	return p;
+}
+
+
+bool CDynamicSCardReader::IsAvailable()
+{
+	return true;
+}
+
+
+bool CDynamicSCardReader::IsReaderAvailable(LPCTSTR pszReader)
+{
+	return true;
+}
+
+
+bool CDynamicSCardReader::CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength)
+{
+	return false;
+}
+
+
+bool CDynamicSCardReader::Transmit(const void *pSendData,DWORD SendSize,void *pRecvData,DWORD *pRecvSize)
+{
+	if (!m_hSCard) {
+		SetError(TEXT("カードリーダが開かれていません。"));
+		return false;
+	}
+
+	LONG Result = m_pSCardTransmit(m_hSCard, SCARD_PCI_T1,
+		static_cast<LPCBYTE>(pSendData), SendSize, NULL, static_cast<LPBYTE>(pRecvData), pRecvSize);
+
+	if (Result != SCARD_S_SUCCESS) {
+		TCHAR szMessage[256];
+		GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+		SetError(TEXT("コマンド送信エラーです。"), NULL, szMessage);
+		return false;
+	}
+
+	ClearError();
+
+	return true;
+}
+
+#endif	// CARDREADER_SCARD_DYNAMIC_SUPPORT
+
+
+
+
+#ifdef CARDREADER_BONCASCLIENT_SUPPORT
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// BonCasClient
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#define BONCASCLIENT_MODULE_NAME TEXT("BonCasClient.dll")
+
+
+CBonCasClientCardReader::CBonCasClientCardReader()
+	: m_hLib(NULL)
+	, m_hSCard(0)
+	, m_pReaderList(NULL)
+	, m_pszReaderName(NULL)
+
+	, m_pCasLinkReleaseContext(NULL)
+	, m_pCasLinkConnect(NULL)
+	, m_pCasLinkDisconnect(NULL)
+	, m_pCasLinkTransmit(NULL)
+{
+}
+
+
+CBonCasClientCardReader::~CBonCasClientCardReader()
+{
+	Close();
+}
+
+
+void CBonCasClientCardReader::GetModulePath(LPTSTR pszPath) const
+{
+	::GetModuleFileName(NULL, pszPath, MAX_PATH);
+	::lstrcpy(::PathFindFileName(pszPath), BONCASCLIENT_MODULE_NAME);
+}
+
+
+bool CBonCasClientCardReader::Load(LPCTSTR pszFileName)
+{
+	m_hLib = ::LoadLibrary(pszFileName);
+	if (m_hLib == NULL) {
+		SetError(TEXT("ライブラリを読み込めません。"));
+		return false;
+	}
+
+	typedef LONG (WINAPI *CasLinkEstablishContextFunc)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
+	typedef LONG (WINAPI *CasLinkListReadersFunc)(SCARDCONTEXT, LPCTSTR, LPTSTR, LPDWORD);
+	CasLinkEstablishContextFunc pEstablishContext;
+	CasLinkListReadersFunc pListReaders;
+
+	if (!GetLibraryFunc(m_hLib, pEstablishContext, "CasLinkEstablishContext")
+	 || !GetLibraryFunc(m_hLib, pListReaders, FUNC_NAME("CasLinkListReaders"))
+	 || !GetLibraryFunc(m_hLib, m_pCasLinkReleaseContext, "CasLinkReleaseContext")
+	 || !GetLibraryFunc(m_hLib, m_pCasLinkConnect, "CasLinkConnect")
+	 || !GetLibraryFunc(m_hLib, m_pCasLinkDisconnect, "CasLinkDisconnect")
+	 || !GetLibraryFunc(m_hLib, m_pCasLinkTransmit, "CasLinkTransmit")) {
+		::FreeLibrary(m_hLib);
+		m_hLib = NULL;
+		SetError(TEXT("関数のアドレスを取得できません。"));
+		return false;
+	}
+
+	if (pEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &m_SCardContext) != SCARD_S_SUCCESS) {
+		::FreeLibrary(m_hLib);
+		m_hLib = NULL;
+		SetError(TEXT("コンテキストを確立できません。"));
+		return false;
+	}
+
+	// カードリーダを列挙する
+	DWORD dwBuffLength = 0;
+
+	if (pListReaders(m_SCardContext, NULL, NULL , &dwBuffLength) == SCARD_S_SUCCESS) {
+		m_pReaderList = new TCHAR[dwBuffLength];
+		if (pListReaders(m_SCardContext, NULL, m_pReaderList, &dwBuffLength) == SCARD_S_SUCCESS) {
+			if (!CheckReaderList(m_pReaderList, dwBuffLength)) {
+				Close();
+				SetError(TEXT("カードリーダのリストが不正です。"));
+				return false;
+			}
+		} else {
+			delete [] m_pReaderList;
+			m_pReaderList = NULL;
+		}
+	}
+
+	return true;
+}
+
+
+bool CBonCasClientCardReader::Connect(LPCTSTR pszReader)
+{
+	LONG Result;
+	DWORD dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
+
+	Result = m_pCasLinkConnect(m_SCardContext, pszReader, SCARD_SHARE_SHARED, SCARD_PROTOCOL_T1, &m_hSCard, &dwActiveProtocol);
+	if (Result != SCARD_S_SUCCESS) {
+		TCHAR szMessage[256];
+		GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+		SetError(TEXT("カードリーダに接続できません。"), NULL, szMessage);
+		return false;
+	}
+
+	if (dwActiveProtocol != SCARD_PROTOCOL_T1) {
+		SetError(TEXT("アクティブプロトコルが不正です。"));
+		return false;
+	}
+
+	return true;
+}
+
+
+bool CBonCasClientCardReader::Open(LPCTSTR pszReader)
+{
+	// 一旦クローズする
+	Close();
+
+	// ライブラリ読み込み
+	TCHAR szFileName[MAX_PATH];
+	GetModulePath(szFileName);
+	if (!Load(szFileName))
+		return false;
+
+	if (pszReader) {
+		// 指定されたカードリーダに対して接続を試みる
+		if (!Connect(pszReader)) {
+			Close();
+			return false;
+		}
+	} else {
+		// 全てのカードリーダに対して接続を試みる
+		if (m_pReaderList == NULL || m_pReaderList[0] == _T('\0')) {
+			Close();
+			SetError(TEXT("カードリーダが見付かりません。"));
+			return false;
+		}
+
+		LPCTSTR p = m_pReaderList;
+		while (*p) {
+			if (Connect(p)) {
+				pszReader = p;
+				break;
+			}
+			p += ::lstrlen(p) + 1;
+		}
+		if (!pszReader) {
+			Close();
+			return false;
+		}
+	}
+
+	m_pszReaderName = StdUtil::strdup(pszReader);
+
+	ClearError();
+
+	return true;
+}
+
+
+void CBonCasClientCardReader::Close()
+{
+	if (m_hSCard) {
+		m_pCasLinkDisconnect(m_hSCard, SCARD_LEAVE_CARD);
+		m_hSCard = 0;
+	}
+
+	if (m_pszReaderName) {
+		delete [] m_pszReaderName;
+		m_pszReaderName = NULL;
+	}
+
+	if (m_hLib) {
+		m_pCasLinkReleaseContext(m_SCardContext);
+
+		::FreeLibrary(m_hLib);
+		m_hLib = NULL;
+	}
+
+	if (m_pReaderList) {
+		delete [] m_pReaderList;
+		m_pReaderList = NULL;
+	}
+}
+
+
+LPCTSTR CBonCasClientCardReader::GetReaderName() const
+{
+	return m_pszReaderName;
+}
+
+
+int CBonCasClientCardReader::NumReaders() const
+{
+	if (!m_pReaderList)
+		return 0;
+	LPCTSTR p = m_pReaderList;
+	int i;
+	for (i = 0; *p; i++) {
+		p += ::lstrlen(p) + 1;
+	}
+	return i;
+}
+
+
+LPCTSTR CBonCasClientCardReader::EnumReader(int Index) const
+{
+	if (!m_pReaderList)
+		return NULL;
+	LPCTSTR p = m_pReaderList;
+	for (int i = 0; i < Index; i++) {
+		if (!*p)
+			return NULL;
+		p += ::lstrlen(p) + 1;
+	}
+	return p;
+}
+
+
+bool CBonCasClientCardReader::IsAvailable()
+{
+	TCHAR szPath[MAX_PATH];
+
+	GetModulePath(szPath);
+
+	return ::PathFileExists(szPath) != FALSE;
+}
+
+
+bool CBonCasClientCardReader::IsReaderAvailable(LPCTSTR pszReader)
+{
+	return true;
+}
+
+
+bool CBonCasClientCardReader::CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength)
+{
+	bool bAvailable = IsAvailable();
+
+	*pbAvailable = bAvailable;
+
+	if (pszMessage) {
+		if (bAvailable) {
+			::lstrcpyn(pszMessage, BONCASCLIENT_MODULE_NAME TEXT(" が見付かりました。"), MaxLength);
+		} else {
+			::lstrcpyn(pszMessage, BONCASCLIENT_MODULE_NAME TEXT(" が見付かりません。"), MaxLength);
+		}
+	}
+
+	return true;
+}
+
+
+bool CBonCasClientCardReader::Transmit(const void *pSendData,DWORD SendSize,void *pRecvData,DWORD *pRecvSize)
+{
+	if (!m_hSCard) {
+		SetError(TEXT("カードリーダが開かれていません。"));
+		return false;
+	}
+
+	LONG Result = m_pCasLinkTransmit(m_hSCard, SCARD_PCI_T1,
+		static_cast<LPCBYTE>(pSendData), SendSize, NULL, static_cast<LPBYTE>(pRecvData), pRecvSize);
+
+	if (Result != SCARD_S_SUCCESS) {
+		TCHAR szMessage[256];
+		GetSCardErrorMessage(Result, szMessage, _countof(szMessage));
+		SetError(TEXT("コマンド送信エラーです。"), NULL, szMessage);
+		return false;
+	}
+
+	ClearError();
+
+	return true;
+}
+
+#endif	// CARDREADER_BONCASCLIENT_SUPPORT
diff -ruN a/TSTask/BonTsEngine/CardReader.h b/TSTask/BonTsEngine/CardReader.h
--- a/TSTask/BonTsEngine/CardReader.h	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/CardReader.h	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,150 @@
+#ifndef CARD_READER_H
+#define CARD_READER_H
+
+
+#include <winscard.h>
+#include "BonBaseClass.h"
+
+
+// カードリーダー基底クラス
+class __declspec(novtable) CCardReader : public CBonBaseClass
+{
+public:
+	enum ReaderType {
+		READER_NONE,
+		READER_SCARD,
+#ifdef CARDREADER_SCARD_DYNAMIC_SUPPORT
+		READER_SCARD_DYNAMIC,
+#endif
+#ifdef CARDREADER_BONCASCLIENT_SUPPORT
+		READER_BONCASCLIENT,
+#endif
+		READER_TRAILER,
+		READER_LAST = READER_TRAILER-1
+	};
+
+	CCardReader();
+	virtual ~CCardReader();
+	virtual bool Open(LPCTSTR pszReader = NULL) = 0;
+	virtual void Close() = 0;
+	virtual LPCTSTR GetReaderName() const = 0;
+	virtual int NumReaders() const { return 1; }
+	virtual LPCTSTR EnumReader(int Index) const;
+	ReaderType GetReaderType() const { return m_ReaderType; }
+	virtual bool IsAvailable() = 0;
+	virtual bool IsReaderAvailable(LPCTSTR pszReader) = 0;
+	virtual bool CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength) = 0;
+	virtual bool Transmit(const void *pSendData, DWORD SendSize, void *pRecvData, DWORD *pRecvSize) = 0;
+
+	static CCardReader *CreateCardReader(ReaderType Type);
+
+private:
+	ReaderType m_ReaderType;
+};
+
+// スマートカードリーダー
+class CSCardReader : public CCardReader
+{
+	SCARDCONTEXT m_SCardContext;
+	SCARDHANDLE m_hSCard;
+	bool m_bIsEstablish;
+	LPTSTR m_pReaderList;
+	int m_NumReaders;
+	LPTSTR m_pszReaderName;
+
+public:
+	CSCardReader();
+	~CSCardReader();
+
+// CCardReader
+	bool Open(LPCTSTR pszReader) override;
+	void Close() override;
+	LPCTSTR GetReaderName() const override;
+	int NumReaders() const override;
+	LPCTSTR EnumReader(int Index) const override;
+	bool IsAvailable() override;
+	bool IsReaderAvailable(LPCTSTR pszReader) override;
+	bool CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength) override;
+	bool Transmit(const void *pSendData, DWORD SendSize, void *pRecvData, DWORD *pRecvSize) override;
+};
+
+#ifdef CARDREADER_SCARD_DYNAMIC_SUPPORT
+class CDynamicSCardReader : public CCardReader
+{
+	HMODULE m_hLib;
+	SCARDCONTEXT m_SCardContext;
+	SCARDHANDLE m_hSCard;
+	LPTSTR m_pReaderList;
+	LPTSTR m_pszReaderName;
+	typedef LONG (WINAPI *SCardReleaseContextFunc)(SCARDCONTEXT);
+	typedef LONG (WINAPI *SCardConnectFunc)(SCARDCONTEXT, LPCTSTR, DWORD, DWORD, LPSCARDHANDLE, LPDWORD);
+	typedef LONG (WINAPI *SCardDisconnectFunc)(SCARDHANDLE, DWORD);
+	typedef LONG (WINAPI *SCardTransmitFunc)(SCARDHANDLE, LPCSCARD_IO_REQUEST, LPCBYTE,
+											 DWORD, LPSCARD_IO_REQUEST, LPBYTE, LPDWORD);
+	SCardReleaseContextFunc m_pSCardReleaseContext;
+	SCardConnectFunc m_pSCardConnect;
+	SCardDisconnectFunc m_pSCardDisconnect;
+	SCardTransmitFunc m_pSCardTransmit;
+
+	bool Load(LPCTSTR pszFileName);
+	void Unload();
+
+public:
+	CDynamicSCardReader();
+	~CDynamicSCardReader();
+
+// CCardReader
+	bool Open(LPCTSTR pszReader) override;
+	void Close() override;
+	LPCTSTR GetReaderName() const override;
+	int NumReaders() const override;
+	LPCTSTR EnumReader(int Index) const override;
+	bool IsAvailable() override;
+	bool IsReaderAvailable(LPCTSTR pszReader) override;
+	bool CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength) override;
+	bool Transmit(const void *pSendData, DWORD SendSize, void *pRecvData, DWORD *pRecvSize) override;
+};
+#endif	// CARDREADER_SCARD_DYNAMIC_SUPPORT
+
+#ifdef CARDREADER_BONCASCLIENT_SUPPORT
+// BonCasClient
+class CBonCasClientCardReader : public CCardReader
+{
+	HMODULE m_hLib;
+	SCARDCONTEXT m_SCardContext;
+	SCARDHANDLE m_hSCard;
+	LPTSTR m_pReaderList;
+	LPTSTR m_pszReaderName;
+	typedef LONG (WINAPI *CasLinkReleaseContextFunc)(SCARDCONTEXT);
+	typedef LONG (WINAPI *CasLinkConnectFunc)(SCARDCONTEXT, LPCTSTR, DWORD, DWORD, LPSCARDHANDLE, LPDWORD);
+	typedef LONG (WINAPI *CasLinkDisconnectFunc)(SCARDHANDLE, DWORD);
+	typedef LONG (WINAPI *CasLinkTransmitFunc)(SCARDHANDLE, LPCSCARD_IO_REQUEST, LPCBYTE,
+											   DWORD, LPSCARD_IO_REQUEST, LPBYTE, LPDWORD);
+	CasLinkReleaseContextFunc m_pCasLinkReleaseContext;
+	CasLinkConnectFunc m_pCasLinkConnect;
+	CasLinkDisconnectFunc m_pCasLinkDisconnect;
+	CasLinkTransmitFunc m_pCasLinkTransmit;
+
+	void GetModulePath(LPTSTR pszPath) const;
+	bool Load(LPCTSTR pszFileName);
+	bool Connect(LPCTSTR pszReader);
+
+public:
+	CBonCasClientCardReader();
+	~CBonCasClientCardReader();
+
+// CCardReader
+	bool Open(LPCTSTR pszReader) override;
+	void Close() override;
+	LPCTSTR GetReaderName() const override;
+	int NumReaders() const override;
+	LPCTSTR EnumReader(int Index) const override;
+	bool IsAvailable() override;
+	bool IsReaderAvailable(LPCTSTR pszReader) override;
+	bool CheckAvailability(bool *pbAvailable, LPTSTR pszMessage, int MaxLength) override;
+	bool Transmit(const void *pSendData, DWORD SendSize, void *pRecvData, DWORD *pRecvSize) override;
+};
+#endif	// CARDREADER_BONCASCLIENT_SUPPORT
+
+
+#endif
diff -ruN a/TSTask/BonTsEngine/CasCard.cpp b/TSTask/BonTsEngine/CasCard.cpp
--- a/TSTask/BonTsEngine/CasCard.cpp	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/CasCard.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,631 @@
+// CasCard.cpp: CCasCard クラスのインプリメンテーション
+//
+//////////////////////////////////////////////////////////////////////
+
+#include "stdafx.h"
+#include "CasCard.h"
+#include "StdUtil.h"
+
+#ifdef _DEBUG
+#undef THIS_FILE
+static char THIS_FILE[]=__FILE__;
+#define new DEBUG_NEW
+#endif
+
+
+// レスポンス受信バッファサイズ
+#define RECEIVE_BUFFER_SIZE 1024
+
+#define CARD_NOT_OPEN_ERROR_TEXT	TEXT("カードリーダが開かれていません。")
+#define BAD_ARGUMENT_ERROR_TEXT		TEXT("引数が不正です。")
+#define ECM_REFUSED_ERROR_TEXT		TEXT("ECMが受け付けられません。")
+
+
+inline WORD GetReturnCode(const BYTE *pRecvData)
+{
+	return (WORD)((pRecvData[4] << 8) | pRecvData[5]);
+}
+
+
+
+
+CCasCard::CCasCard()
+	: m_pCardReader(NULL)
+{
+	// 内部状態初期化
+	::ZeroMemory(&m_CasCardInfo, sizeof(m_CasCardInfo));
+	::ZeroMemory(&m_EcmStatus, sizeof(m_EcmStatus));
+}
+
+
+CCasCard::~CCasCard()
+{
+	CloseCard();
+}
+
+
+const DWORD CCasCard::GetCardReaderNum(void) const
+{
+	// カードリーダー数を返す
+	if (m_pCardReader)
+		return m_pCardReader->NumReaders();
+	return 0;
+}
+
+
+LPCTSTR CCasCard::EnumCardReader(const DWORD dwIndex) const
+{
+	if (m_pCardReader)
+		return m_pCardReader->EnumReader(dwIndex);
+	return NULL;
+}
+
+
+const bool CCasCard::OpenCard(CCardReader::ReaderType ReaderType, LPCTSTR lpszReader)
+{
+	// 一旦クローズする
+	CloseCard();
+
+	m_pCardReader = CCardReader::CreateCardReader(ReaderType);
+	if (m_pCardReader == NULL) {
+		SetError(ERR_CARDOPENERROR, TEXT("カードリーダのタイプが無効です。"));
+		return false;
+	}
+
+	bool bSuccess = false;
+
+	if (lpszReader || m_pCardReader->NumReaders() <= 1) {
+		// 指定されたリーダーを開く
+		if (OpenAndInitialize(lpszReader))
+			bSuccess = true;
+	} else {
+		// 利用可能なリーダーを探して開く
+		LPCTSTR pszReaderName;
+
+		for (int i = 0; (pszReaderName = m_pCardReader->EnumReader(i)) != NULL; i++) {
+			if (OpenAndInitialize(pszReaderName)) {
+				bSuccess = true;
+				break;
+			}
+		}
+	}
+
+	if (!bSuccess) {
+		delete m_pCardReader;
+		m_pCardReader = NULL;
+		return false;
+	}
+
+	ClearError();
+
+	return true;
+}
+
+
+void CCasCard::CloseCard(void)
+{
+	// カードをクローズする
+	if (m_pCardReader) {
+		m_pCardReader->Close();
+		delete m_pCardReader;
+		m_pCardReader = NULL;
+	}
+}
+
+
+const bool CCasCard::ReOpenCard()
+{
+	if (m_pCardReader == NULL) {
+		SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+
+	CCardReader::ReaderType Type = m_pCardReader->GetReaderType();
+	LPTSTR pszReaderName = StdUtil::strdup(m_pCardReader->GetReaderName());
+	bool bResult=OpenCard(Type, pszReaderName);
+	delete [] pszReaderName;
+	return bResult;
+}
+
+
+const bool CCasCard::IsCardOpen() const
+{
+	return m_pCardReader != NULL;
+}
+
+
+CCardReader::ReaderType CCasCard::GetCardReaderType() const
+{
+	if (m_pCardReader)
+		return m_pCardReader->GetReaderType();
+	return CCardReader::READER_NONE;
+}
+
+
+LPCTSTR CCasCard::GetCardReaderName() const
+{
+	if (m_pCardReader)
+		return m_pCardReader->GetReaderName();
+	return NULL;
+}
+
+
+const bool CCasCard::OpenAndInitialize(LPCTSTR pszReader)
+{
+	if (!m_pCardReader->Open(pszReader)) {
+		SetError(m_pCardReader->GetLastErrorException());
+		SetErrorCode(ERR_CARDOPENERROR);
+		return false;
+	}
+
+	// カード初期化(失敗したらリトライしてみる)
+	if (!InitialSetting() && !InitialSetting()) {
+		m_pCardReader->Close();
+		return false;
+	}
+
+	return true;
+}
+
+
+const bool CCasCard::InitialSetting(void)
+{
+	// 「Initial Setting Conditions Command」を処理する
+	/*
+	if (!m_pCardReader) {
+		SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+	*/
+
+	// バッファ準備
+	DWORD dwRecvSize;
+	BYTE RecvData[RECEIVE_BUFFER_SIZE];
+
+	// 初期設定条件コマンド送信
+	static const BYTE InitSettingCmd[] = {0x90U, 0x30U, 0x00U, 0x00U, 0x00U};
+	::ZeroMemory(RecvData, sizeof(RecvData));
+	dwRecvSize = sizeof(RecvData);
+	TRACE(TEXT("Send \"Initial Setting Conditions Command\"\n"));
+	if (!m_pCardReader->Transmit(InitSettingCmd, sizeof(InitSettingCmd), RecvData, &dwRecvSize)) {
+		SetError(ERR_TRANSMITERROR, m_pCardReader->GetLastErrorText());
+		return false;
+	}
+
+	if (dwRecvSize < 57UL) {
+		SetError(ERR_TRANSMITERROR, TEXT("受信データのサイズが不正です。"));
+		return false;
+	}
+
+	// レスポンス解析
+	m_CasCardInfo.CASystemID = ((WORD)RecvData[6] << 8) | (WORD)RecvData[7];
+	::CopyMemory(m_CasCardInfo.CardID, &RecvData[8], 6);		// +8	Card ID
+	m_CasCardInfo.CardType = RecvData[14];
+	m_CasCardInfo.MessagePartitionLength = RecvData[15];
+	::CopyMemory(m_CasCardInfo.SystemKey, &RecvData[16], 32);	// +16	Descrambling system key
+	::CopyMemory(m_CasCardInfo.InitialCbc, &RecvData[48], 8);	// +48	Descrambler CBC initial value
+
+	if (::memcmp(m_CasCardInfo.CardID, "\0\0\0\0\0", 6) == 0) {
+		SetError(ERR_TRANSMITERROR, TEXT("カードIDが不正です。"));
+		return false;
+	}
+
+	// カードID情報取得コマンド送信
+	static const BYTE CardIDInfoCmd[] = {0x90, 0x32, 0x00, 0x00, 0x00};
+	::ZeroMemory(RecvData, sizeof(RecvData));
+	dwRecvSize = sizeof(RecvData);
+	TRACE(TEXT("Send \"Card ID Information Acquire Command\"\n"));
+	if (!m_pCardReader->Transmit(CardIDInfoCmd, sizeof(CardIDInfoCmd), RecvData, &dwRecvSize)) {
+		SetError(ERR_TRANSMITERROR, m_pCardReader->GetLastErrorText());
+		return false;
+	}
+
+	if (dwRecvSize < 19) {
+		SetError(ERR_TRANSMITERROR, TEXT("受信データのサイズが不正です。"));
+		return false;
+	}
+
+	m_CasCardInfo.CardManufacturerID = RecvData[7];
+	m_CasCardInfo.CardVersion = RecvData[8];
+	m_CasCardInfo.CheckCode = ((WORD)RecvData[15] << 8) | (WORD)RecvData[16];
+
+	if (::memcmp(&RecvData[9], "\0\0\0\0\0", 6) == 0) {
+		SetError(ERR_TRANSMITERROR, TEXT("カードIDが不正です。"));
+		return false;
+	}
+
+	// ECMステータス初期化
+	::ZeroMemory(&m_EcmStatus, sizeof(m_EcmStatus));
+
+	return true;
+}
+
+
+const bool CCasCard::GetCasCardInfo(CasCardInfo *pInfo) const
+{
+	if (!m_pCardReader) {
+		//SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+
+	if (pInfo == NULL) {
+		//SetError(ERR_BADARGUMENT, BAD_ARGUMENT_ERROR_TEXT);
+		return false;
+	}
+
+	*pInfo = m_CasCardInfo;
+
+	//ClearError();
+
+	return true;
+}
+
+
+const bool CCasCard::GetCASystemID(WORD *pID) const
+{
+	if (!m_pCardReader) {
+		//SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+
+	if (pID == NULL) {
+		//SetError(ERR_BADARGUMENT, BAD_ARGUMENT_ERROR_TEXT);
+		return false;
+	}
+
+	*pID = m_CasCardInfo.CASystemID;
+
+	//ClearError();
+
+	return true;
+}
+
+
+const BYTE * CCasCard::GetCardID(void) const
+{
+	// Card ID を返す
+	if (!m_pCardReader) {
+		//SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return NULL;
+	}
+
+	//ClearError();
+
+	return m_CasCardInfo.CardID;
+}
+
+
+const BYTE CCasCard::GetCardType(void) const
+{
+	if (!m_pCardReader) {
+		//SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return CARDTYPE_INVALID;
+	}
+
+	//ClearError();
+
+	return m_CasCardInfo.CardType;
+}
+
+
+const BYTE CCasCard::GetMessagePartitionLength(void) const
+{
+	return m_CasCardInfo.MessagePartitionLength;
+}
+
+
+const BYTE * CCasCard::GetInitialCbc(void) const
+{
+	// Descrambler CBC Initial Value を返す
+	if (!m_pCardReader) {
+		//SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return NULL;
+	}
+
+	//ClearError();
+
+	return m_CasCardInfo.InitialCbc;
+}
+
+
+const BYTE * CCasCard::GetSystemKey(void) const
+{
+	// Descrambling System Key を返す
+	if (!m_pCardReader) {
+		//SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return NULL;
+	}
+
+	//ClearError();
+
+	return m_CasCardInfo.SystemKey;
+}
+
+
+const char CCasCard::GetCardManufacturerID() const
+{
+	return m_CasCardInfo.CardManufacturerID;
+}
+
+
+const BYTE CCasCard::GetCardVersion() const
+{
+	return m_CasCardInfo.CardVersion;
+}
+
+
+const int CCasCard::FormatCardID(LPTSTR pszText, int MaxLength) const
+{
+	if (pszText == NULL || MaxLength <= 0)
+		return 0;
+
+	ULONGLONG ID;
+
+	ID = ((((ULONGLONG)(m_CasCardInfo.CardID[0] & 0x1F) << 40) |
+		   ((ULONGLONG)m_CasCardInfo.CardID[1] << 32) |
+		   ((ULONGLONG)m_CasCardInfo.CardID[2] << 24) |
+		   ((ULONGLONG)m_CasCardInfo.CardID[3] << 16) |
+		   ((ULONGLONG)m_CasCardInfo.CardID[4] << 8) |
+		    (ULONGLONG)m_CasCardInfo.CardID[5]) * 100000ULL) +
+		 (ULONGLONG)m_CasCardInfo.CheckCode;
+	return StdUtil::snprintf(pszText, MaxLength,
+			TEXT("%d%03lu %04lu %04lu %04lu %04lu"),
+			m_CasCardInfo.CardID[0] >> 5,
+			(unsigned long)(ID / (10000ULL * 10000ULL * 10000ULL * 10000ULL)) % 10000,
+			(unsigned long)(ID / (10000ULL * 10000ULL * 10000ULL)) % 10000,
+			(unsigned long)(ID / (10000ULL * 10000ULL) % 10000ULL),
+			(unsigned long)(ID / 10000ULL % 10000ULL),
+			(unsigned long)(ID % 10000ULL));
+}
+
+
+const BYTE * CCasCard::GetKsFromEcm(const BYTE *pEcmData, const DWORD dwEcmSize)
+{
+	// 「ECM Receive Command」を処理する
+	if (!m_pCardReader) {
+		SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return NULL;
+	}
+
+	// ECMサイズをチェック
+	if (!pEcmData || (dwEcmSize < MIN_ECM_DATA_SIZE) || (dwEcmSize > MAX_ECM_DATA_SIZE)) {
+		SetError(ERR_BADARGUMENT, BAD_ARGUMENT_ERROR_TEXT);
+		return NULL;
+	}
+
+	// キャッシュをチェックする
+	if (m_EcmStatus.dwLastEcmSize == dwEcmSize
+			&& ::memcmp(m_EcmStatus.LastEcmData, pEcmData, dwEcmSize) == 0) {
+		// ECMが同一の場合はキャッシュ済みKsを返す
+		if (m_EcmStatus.bSucceeded) {
+			ClearError();
+			return m_EcmStatus.KsData;
+		} else {
+			SetError(ERR_ECMREFUSED, ECM_REFUSED_ERROR_TEXT);
+			return NULL;
+		}
+	}
+
+	// バッファ準備
+	static const BYTE EcmReceiveCmd[] = {0x90, 0x34, 0x00, 0x00};
+	BYTE SendData[MAX_ECM_DATA_SIZE + 6];
+	BYTE RecvData[RECEIVE_BUFFER_SIZE];
+	::ZeroMemory(RecvData, sizeof(RecvData));
+
+	// コマンド構築
+	::CopyMemory(SendData, EcmReceiveCmd, sizeof(EcmReceiveCmd));				// CLA, INS, P1, P2
+	SendData[sizeof(EcmReceiveCmd)] = (BYTE)dwEcmSize;							// COMMAND DATA LENGTH
+	::CopyMemory(&SendData[sizeof(EcmReceiveCmd) + 1], pEcmData, dwEcmSize);	// ECM
+	SendData[sizeof(EcmReceiveCmd) + dwEcmSize + 1] = 0x00U;					// RESPONSE DATA LENGTH
+
+	// コマンド送信
+	DWORD dwRecvSize = sizeof(RecvData);
+	if (!m_pCardReader->Transmit(SendData, sizeof(EcmReceiveCmd) + dwEcmSize + 2UL, RecvData, &dwRecvSize)){
+		::ZeroMemory(&m_EcmStatus, sizeof(m_EcmStatus));
+		SetError(ERR_TRANSMITERROR, m_pCardReader->GetLastErrorText());
+		return NULL;
+	}
+
+	// サイズチェック
+	if (dwRecvSize != 25UL) {
+		::ZeroMemory(&m_EcmStatus, sizeof(m_EcmStatus));
+		SetError(ERR_TRANSMITERROR, TEXT("ECMのレスポンスサイズが不正です。"));
+		return NULL;
+	}
+
+	// ECMデータを保存する
+	m_EcmStatus.dwLastEcmSize = dwEcmSize;
+	::CopyMemory(m_EcmStatus.LastEcmData, pEcmData, dwEcmSize);
+
+	// レスポンス解析
+	::CopyMemory(m_EcmStatus.KsData, &RecvData[6], sizeof(m_EcmStatus.KsData));
+
+	// リターンコード解析
+	switch (GetReturnCode(RecvData)) {
+	// Purchased: Viewing
+	case 0x0200U :	// Payment-deferred PPV
+	case 0x0400U :	// Prepaid PPV
+	case 0x0800U :	// Tier
+
+	case 0x4480U :	// Payment-deferred PPV
+	case 0x4280U :	// Prepaid PPV
+		ClearError();
+		m_EcmStatus.bSucceeded = true;
+		return m_EcmStatus.KsData;
+	}
+	// 上記以外(視聴不可)
+
+	m_EcmStatus.bSucceeded = false;
+	SetError(ERR_ECMREFUSED, ECM_REFUSED_ERROR_TEXT);
+
+	return NULL;
+}
+
+
+const bool CCasCard::SendEmmSection(const BYTE *pEmmData, const DWORD dwEmmSize)
+{
+	// 「EMM Receive Command」を処理する
+	if (!m_pCardReader) {
+		SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+
+	if (pEmmData == NULL || dwEmmSize < 17UL || dwEmmSize > MAX_EMM_DATA_SIZE) {
+		SetError(ERR_BADARGUMENT, BAD_ARGUMENT_ERROR_TEXT);
+		return false;
+	}
+
+	TRACE(TEXT("Send \"EMM Receive Command\"\n"));
+
+	static const BYTE EmmReceiveCmd[] = {0x90, 0x36, 0x00, 0x00};
+	BYTE SendData[MAX_EMM_DATA_SIZE + 6], RecvData[RECEIVE_BUFFER_SIZE];
+
+	::CopyMemory(SendData, EmmReceiveCmd, sizeof(EmmReceiveCmd));
+	SendData[sizeof(EmmReceiveCmd)] = (BYTE)dwEmmSize;
+	::CopyMemory(&SendData[sizeof(EmmReceiveCmd) + 1], pEmmData, dwEmmSize);
+	SendData[sizeof(EmmReceiveCmd) + 1 + dwEmmSize] = 0x00;
+
+	::ZeroMemory(RecvData, sizeof(RecvData));
+	DWORD RecvSize = sizeof(RecvData);
+	if (!m_pCardReader->Transmit(SendData, sizeof(EmmReceiveCmd) + dwEmmSize + 2UL, RecvData, &RecvSize)) {
+		SetError(ERR_TRANSMITERROR, m_pCardReader->GetLastErrorText());
+		return false;
+	}
+
+	if (RecvSize != 8UL) {
+		SetError(ERR_TRANSMITERROR, TEXT("EMMのレスポンスサイズが不正です。"));
+		return false;
+	}
+
+	const WORD ReturnCode = GetReturnCode(RecvData);
+	TRACE(TEXT(" -> Return Code %04x\n"), ReturnCode);
+	switch (ReturnCode) {
+	case 0x2100U :	// 正常終了
+		ClearError();
+		return true;
+
+	case 0xA102U :	// 非運用(運用外プロトコル番号)
+		SetError(ERR_EMMERROR, TEXT("プロトコル番号が運用外です。"));
+		break;
+
+	case 0xA107U :	// セキュリティエラー(EMM改ざんエラー)
+		SetError(ERR_EMMERROR, TEXT("セキュリティエラーです。"));
+		break;
+
+	default:
+		SetError(ERR_EMMERROR, TEXT("EMMが受け付けられません。"));
+		break;
+	}
+
+	return false;
+}
+
+
+const bool CCasCard::ConfirmContract(const BYTE *pVerificationData, const DWORD DataSize, const WORD Date)
+{
+	// 「Contract Confirmation Command」を処理する
+	if (!m_pCardReader) {
+		SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+
+	if (pVerificationData == NULL || DataSize < 1 || DataSize > 253) {
+		SetError(ERR_BADARGUMENT, BAD_ARGUMENT_ERROR_TEXT);
+		return false;
+	}
+
+	TRACE(TEXT("Send \"Contract Confirmation Command\"\n"));
+
+	static const BYTE ContractConfirmCmd[] = {0x90, 0x3C, 0x00, 0x00};
+	BYTE SendData[255 + 6], RecvData[RECEIVE_BUFFER_SIZE];
+
+	::CopyMemory(SendData, ContractConfirmCmd, sizeof(ContractConfirmCmd));
+	SendData[sizeof(ContractConfirmCmd)] = (BYTE)(DataSize + 2);
+	SendData[sizeof(ContractConfirmCmd) + 1] = Date >> 8;
+	SendData[sizeof(ContractConfirmCmd) + 2] = Date & 0xFF;
+	::CopyMemory(&SendData[sizeof(ContractConfirmCmd) + 3], pVerificationData, DataSize);
+	SendData[sizeof(ContractConfirmCmd) + 3 + DataSize] = 0x00;
+
+	::ZeroMemory(RecvData, sizeof(RecvData));
+	DWORD RecvSize = sizeof(RecvData);
+	if (!m_pCardReader->Transmit(SendData, sizeof(ContractConfirmCmd) + DataSize + 4UL, RecvData, &RecvSize)) {
+		SetError(ERR_TRANSMITERROR, m_pCardReader->GetLastErrorText());
+		return false;
+	}
+
+	if (RecvSize != 20UL) {
+		SetError(ERR_TRANSMITERROR, TEXT("契約確認のレスポンスサイズが不正です。"));
+		return false;
+	}
+
+	const WORD ReturnCode = GetReturnCode(RecvData);
+	TRACE(TEXT(" -> Return Code %04x\n"), ReturnCode);
+	switch (ReturnCode) {
+	// 購入済
+	case 0x0800:	// ティア
+	case 0x0400:	// 前払いPPV
+	case 0x0200:	// 後払いPPV
+		ClearError();
+		return true;
+
+	case 0x8901:	// 非契約:契約外(ティア)
+	case 0x8501:	// 非契約:契約外(前払いPPV)
+	case 0x8301:	// 非契約:契約外(後払いPPV)
+	case 0x8902:	// 非契約:期限切れ(ティア)
+	case 0x8502:	// 非契約:期限切れ(前払いPPV)
+	case 0x8302:	// 非契約:期限切れ(後払いPPV)
+	case 0x8903:	// 非契約:視聴制限(ティア)
+	case 0x8503:	// 非契約:視聴制限(前払いPPV)
+	case 0x8303:	// 非契約:視聴制限(後払いPPV)
+	case 0xA103:	// 非契約(Kwなし)
+		SetError(ERR_UNCONTRACTED, TEXT("契約されていません。"));
+		break;
+
+	case 0x8500:	// 購入可(前払いPPV)
+	case 0x8300:	// 購入可(後払いPPV)
+		SetError(ERR_PURCHASEAVAIL, TEXT("購入されていません。"));
+		break;
+
+	case 0x8109:	// 購入拒否(視聴履歴メモリ満杯)
+	case 0x850F:	// 購入拒否(前払い残金不足)
+		SetError(ERR_PURCHASEREFUSED, TEXT("購入できません。"));
+		break;
+
+	case 0xA102:	// 非運用カード(運用外プロトコル番号)
+		SetError(ERR_NONOPERATIONAL, TEXT("プロトコル番号が運用外です。"));
+		break;
+
+	case 0xA104:	// セキュリティエラー(契約確認情報改ざんエラー)
+		SetError(ERR_SECURITY, TEXT("セキュリティエラーです。"));
+		break;
+
+	default:
+		SetError(ERR_UNKNOWNCODE, TEXT("不明なリターンコードです。"));
+		break;
+	}
+
+	return false;
+}
+
+
+const bool CCasCard::SendCommand(const BYTE *pSendData, const DWORD SendSize, BYTE *pReceiveData, DWORD *pReceiveSize)
+{
+	if (!m_pCardReader) {
+		SetError(ERR_CARDNOTOPEN, CARD_NOT_OPEN_ERROR_TEXT);
+		return false;
+	}
+
+	if (pSendData == NULL || SendSize == 0
+			|| pReceiveData == NULL || pReceiveSize == NULL) {
+		SetError(ERR_BADARGUMENT, BAD_ARGUMENT_ERROR_TEXT);
+		return false;
+	}
+
+	if (!m_pCardReader->Transmit(pSendData, SendSize, pReceiveData, pReceiveSize)) {
+		SetError(ERR_TRANSMITERROR, m_pCardReader->GetLastErrorText());
+		return false;
+	}
+
+	ClearError();
+	return true;
+}
diff -ruN a/TSTask/BonTsEngine/CasCard.h b/TSTask/BonTsEngine/CasCard.h
--- a/TSTask/BonTsEngine/CasCard.h	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/CasCard.h	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,104 @@
+// CasCard.h: CCasCard クラスのインターフェイス
+//
+//////////////////////////////////////////////////////////////////////
+
+#pragma once
+
+
+#include "BonBaseClass.h"
+#include "CardReader.h"
+
+// ECMデータの最小/最大サイズ
+#define MIN_ECM_DATA_SIZE 30
+#define MAX_ECM_DATA_SIZE 256
+// EMMデータの最大サイズ
+#define MAX_EMM_DATA_SIZE 263
+
+class CCasCard : public CBonBaseClass
+{
+public:
+	// エラーコード
+	enum {
+		ERR_NOERROR			= 0x00000000UL,	// エラーなし
+		ERR_INTERNALERROR	= 0x00000001UL,	// 内部エラー
+		ERR_NOTESTABLISHED	= 0x00000002UL,	// コンテキスト確立失敗
+		ERR_NOCARDREADERS	= 0x00000003UL,	// カードリーダがない
+		ERR_ALREADYOPEN		= 0x00000004UL,	// 既にオープン済み
+		ERR_CARDOPENERROR	= 0x00000005UL,	// カードオープン失敗
+		ERR_CARDNOTOPEN		= 0x00000006UL,	// カード未オープン
+		ERR_TRANSMITERROR	= 0x00000007UL,	// 通信エラー
+		ERR_BADARGUMENT		= 0x00000008UL,	// 引数が不正
+		ERR_ECMREFUSED		= 0x00000009UL,	// ECM受付拒否
+		ERR_EMMERROR		= 0x0000000AUL,	// EMM処理エラー
+		ERR_UNCONTRACTED	= 0x0000000BUL,	// 非契約
+		ERR_PURCHASEAVAIL	= 0x0000000CUL,	// 購入可
+		ERR_PURCHASEREFUSED	= 0x0000000DUL,	// 購入拒否
+		ERR_SECURITY		= 0x0000000EUL,	// セキュリティエラー
+		ERR_UNKNOWNCODE		= 0x0000000FUL,	// 不明なコード
+		ERR_NONOPERATIONAL	= 0x00000010UL	// 非運用
+	};
+
+	enum {
+		CARDTYPE_PREPAID	= 0x00,
+		CARDTYPE_STANDARD	= 0x01,
+		CARDTYPE_INVALID	= 0xFF
+	};
+
+	struct CasCardInfo
+	{
+		WORD CASystemID;				// CA_system_id
+		BYTE CardID[6];					// Card ID
+		BYTE CardType;					// Card type
+		BYTE MessagePartitionLength;	// Message partition length
+		BYTE SystemKey[32];				// Descrambling system key
+		BYTE InitialCbc[8];				// Descrambler CBC initial value
+		BYTE CardManufacturerID;		// Manufacturer identifier
+		BYTE CardVersion;				// Version
+		WORD CheckCode;					// Check code
+	};
+
+	CCasCard();
+	~CCasCard();
+
+	const DWORD GetCardReaderNum(void) const;
+	LPCTSTR EnumCardReader(const DWORD dwIndex) const;
+
+	const bool OpenCard(CCardReader::ReaderType ReaderType = CCardReader::READER_SCARD, LPCTSTR lpszReader = NULL);
+	void CloseCard(void);
+	const bool ReOpenCard();
+	const bool IsCardOpen() const;
+	CCardReader::ReaderType GetCardReaderType() const;
+	LPCTSTR GetCardReaderName() const;
+
+	const bool GetCasCardInfo(CasCardInfo *pInfo) const;
+	const bool GetCASystemID(WORD *pID) const;
+	const BYTE * GetCardID(void) const;
+	const BYTE GetCardType(void) const;
+	const BYTE GetMessagePartitionLength(void) const;
+	const BYTE * GetInitialCbc(void) const;
+	const BYTE * GetSystemKey(void) const;
+	const char GetCardManufacturerID() const;
+	const BYTE GetCardVersion() const;
+	const int FormatCardID(LPTSTR pszText, int MaxLength) const;
+
+	const BYTE * GetKsFromEcm(const BYTE *pEcmData, const DWORD dwEcmSize);
+	const bool SendEmmSection(const BYTE *pEmmData, const DWORD dwEmmSize);
+	const bool ConfirmContract(const BYTE *pVerificationData, const DWORD DataSize, const WORD Date);
+	const bool SendCommand(const BYTE *pSendData, const DWORD SendSize, BYTE *pReceiveData, DWORD *pReceiveSize);
+
+protected:
+	const bool OpenAndInitialize(LPCTSTR pszReader);
+	const bool InitialSetting(void);
+
+	CCardReader *m_pCardReader;
+
+	CasCardInfo m_CasCardInfo;
+
+	struct TAG_ECMSTATUS
+	{
+		DWORD dwLastEcmSize;					// 最後に問い合わせのあったECMサイズ
+		BYTE LastEcmData[MAX_ECM_DATA_SIZE];	// 最後に問い合わせのあったECMデータ
+		BYTE KsData[16];						// Ks Odd + Even
+		bool bSucceeded;						// ECMが受け付けられたか
+	} m_EcmStatus;
+};
diff -ruN a/TSTask/BonTsEngine/Multi2Decoder.cpp b/TSTask/BonTsEngine/Multi2Decoder.cpp
--- a/TSTask/BonTsEngine/Multi2Decoder.cpp	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/Multi2Decoder.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,464 @@
+// Multi2Decoder.cpp: CMulti2Decoder クラスのインプリメンテーション
+//
+//////////////////////////////////////////////////////////////////////
+
+#include "stdafx.h"
+#include "Multi2Decoder.h"
+
+#ifdef _DEBUG
+#undef THIS_FILE
+static char THIS_FILE[]=__FILE__;
+#define new DEBUG_NEW
+#endif
+
+
+#define SCRAMBLE_ROUND 4
+
+
+#ifdef MULTI2_USE_INTRINSIC
+#pragma intrinsic(_byteswap_ulong, _byteswap_uint64, _lrotl)
+#endif
+
+
+#ifdef MULTI2_SIMD
+
+#if defined(MULTI2_SIMD_ICC) && !defined(__INTEL_COMPILER)
+
+// ICCでコンパイルしたライブラリの使用
+#include "../ICC/Multi2Decoder/Multi2DecoderSIMD.h"
+#pragma comment(lib, "Multi2Decoder.lib")
+
+#else
+
+#include "Multi2DecoderSIMD.h"
+
+#endif
+
+class CSIMDInitializer
+{
+public:
+	CSIMDInitializer() {
+		Multi2DecoderSIMD::Initialize();
+	}
+};
+
+static CSIMDInitializer SIMDInitializer;
+
+#endif	// MULTI2_SIMD
+
+
+// デスクランブルの統計を取る
+#ifdef MULTI2_STATISTICS
+
+class CMulti2Statistics
+{
+public:
+	CMulti2Statistics()
+	{
+		Reset();
+	}
+
+	~CMulti2Statistics()
+	{
+		TRACE(TEXT("Multi2 statistics\n"));
+		TRACE(TEXT("  Packets %u / Size %llu bytes\n"), m_PacketCount, m_Size);
+		for (size_t i = 0; i < _countof(m_SizeCount); i++) {
+			TRACE(TEXT("  Data size %3d : %u\n"), (int)i, m_SizeCount[i]);
+		}
+	}
+
+	void Reset()
+	{
+		m_PacketCount = 0;
+		ZeroMemory(m_SizeCount, sizeof(m_SizeCount));
+		m_Size = 0;
+	}
+
+	void OnDecode(DWORD Size)
+	{
+		m_PacketCount++;
+		m_SizeCount[Size]++;
+		m_Size += Size;
+	}
+
+private:
+	DWORD m_PacketCount;
+	DWORD m_SizeCount[185];
+	ULONGLONG m_Size;
+};
+
+static CMulti2Statistics Multi2Statistics;
+
+#endif	// MULTI2_STATISTICS
+
+
+inline void CMulti2Decoder::DATKEY::SetHexData(const BYTE *pHexData)
+{
+	// バイトオーダー変換
+#ifndef MULTI2_USE_INTRINSIC
+	Data[7] = pHexData[0];	Data[6] = pHexData[1];	Data[5] = pHexData[2];	Data[4] = pHexData[3];
+	Data[3] = pHexData[4];	Data[2] = pHexData[5];	Data[1] = pHexData[6];	Data[0] = pHexData[7];
+#else
+#ifndef _WIN64
+	dwLeft  = _byteswap_ulong(*reinterpret_cast<const DWORD*>(pHexData + 0));
+	dwRight = _byteswap_ulong(*reinterpret_cast<const DWORD*>(pHexData + 4));
+#else
+	Data64 = _byteswap_uint64(*reinterpret_cast<const unsigned __int64*>(pHexData));
+#endif
+#endif
+}
+
+inline void CMulti2Decoder::DATKEY::GetHexData(BYTE *pHexData) const
+{
+	// バイトオーダー変換
+#ifndef MULTI2_USE_INTRINSIC
+	pHexData[0] = Data[7];	pHexData[1] = Data[6];	pHexData[2] = Data[5];	pHexData[3] = Data[4];
+	pHexData[4] = Data[3];	pHexData[5] = Data[2];	pHexData[6] = Data[1];	pHexData[7] = Data[0];
+#else
+#ifndef _WIN64
+	*reinterpret_cast<DWORD*>(pHexData + 0) = _byteswap_ulong(dwLeft);
+	*reinterpret_cast<DWORD*>(pHexData + 4) = _byteswap_ulong(dwRight);
+#else
+	*reinterpret_cast<unsigned __int64*>(pHexData) = _byteswap_uint64(Data64);
+#endif
+#endif
+}
+
+inline void CMulti2Decoder::SYSKEY::SetHexData(const BYTE *pHexData)
+{
+	// バイトオーダー変換
+#ifndef MULTI2_USE_INTRINSIC
+	Data[ 3] = pHexData[ 0];	Data[ 2] = pHexData[ 1];	Data[ 1] = pHexData[ 2];	Data[ 0] = pHexData[ 3];
+	Data[ 7] = pHexData[ 4];	Data[ 6] = pHexData[ 5];	Data[ 5] = pHexData[ 6];	Data[ 4] = pHexData[ 7];
+	Data[11] = pHexData[ 8];	Data[10] = pHexData[ 9];	Data[ 9] = pHexData[10];	Data[ 8] = pHexData[11];
+	Data[15] = pHexData[12];	Data[14] = pHexData[13];	Data[13] = pHexData[14];	Data[12] = pHexData[15];
+	Data[19] = pHexData[16];	Data[18] = pHexData[17];	Data[17] = pHexData[18];	Data[16] = pHexData[19];
+	Data[23] = pHexData[20];	Data[22] = pHexData[21];	Data[21] = pHexData[22];	Data[20] = pHexData[23];
+	Data[27] = pHexData[24];	Data[26] = pHexData[25];	Data[25] = pHexData[26];	Data[24] = pHexData[27];
+	Data[31] = pHexData[28];	Data[30] = pHexData[29];	Data[29] = pHexData[30];	Data[28] = pHexData[31];
+#else
+#ifndef _WIN64
+	const DWORD *p = reinterpret_cast<const DWORD*>(pHexData);
+	dwKey1 = _byteswap_ulong(p[0]);
+	dwKey2 = _byteswap_ulong(p[1]);
+	dwKey3 = _byteswap_ulong(p[2]);
+	dwKey4 = _byteswap_ulong(p[3]);
+	dwKey5 = _byteswap_ulong(p[4]);
+	dwKey6 = _byteswap_ulong(p[5]);
+	dwKey7 = _byteswap_ulong(p[6]);
+	dwKey8 = _byteswap_ulong(p[7]);
+#else
+	const unsigned __int64 *p = reinterpret_cast<const unsigned __int64*>(pHexData);
+	Data64[0] = _byteswap_uint64(p[0]);
+	Data64[1] = _byteswap_uint64(p[1]);
+	Data64[2] = _byteswap_uint64(p[2]);
+	Data64[3] = _byteswap_uint64(p[3]);
+#endif
+#endif
+}
+
+inline void CMulti2Decoder::SYSKEY::GetHexData(BYTE *pHexData) const
+{
+	// バイトオーダー変換
+#ifndef MULTI2_USE_INTRINSIC
+	pHexData[ 0] = Data[ 3];	pHexData[ 1] = Data[ 2];	pHexData[ 2] = Data[ 1];	pHexData[ 3] = Data[ 0];
+	pHexData[ 4] = Data[ 7];	pHexData[ 5] = Data[ 6];	pHexData[ 6] = Data[ 5];	pHexData[ 7] = Data[ 4];
+	pHexData[ 8] = Data[11];	pHexData[ 9] = Data[10];	pHexData[10] = Data[ 9];	pHexData[11] = Data[ 8];
+	pHexData[12] = Data[15];	pHexData[13] = Data[14];	pHexData[14] = Data[13];	pHexData[15] = Data[12];
+	pHexData[16] = Data[19];	pHexData[17] = Data[18];	pHexData[18] = Data[17];	pHexData[19] = Data[16];
+	pHexData[20] = Data[23];	pHexData[21] = Data[22];	pHexData[22] = Data[21];	pHexData[23] = Data[20];
+	pHexData[24] = Data[27];	pHexData[25] = Data[26];	pHexData[26] = Data[25];	pHexData[27] = Data[24];
+	pHexData[28] = Data[31];	pHexData[29] = Data[30];	pHexData[30] = Data[29];	pHexData[31] = Data[28];
+#else
+#ifndef _WIN64
+	DWORD *p = reinterpret_cast<DWORD*>(pHexData);
+	p[0] = _byteswap_ulong(dwKey1);
+	p[1] = _byteswap_ulong(dwKey2);
+	p[2] = _byteswap_ulong(dwKey3);
+	p[3] = _byteswap_ulong(dwKey4);
+	p[4] = _byteswap_ulong(dwKey5);
+	p[5] = _byteswap_ulong(dwKey6);
+	p[6] = _byteswap_ulong(dwKey7);
+	p[7] = _byteswap_ulong(dwKey8);
+#else
+	unsigned __int64 *p = reinterpret_cast<unsigned __int64*>(pHexData);
+	p[0] = _byteswap_uint64(Data64[0]);
+	p[1] = _byteswap_uint64(Data64[1]);
+	p[2] = _byteswap_uint64(Data64[2]);
+	p[3] = _byteswap_uint64(Data64[3]);
+#endif
+#endif
+}
+
+
+CMulti2Decoder::CMulti2Decoder(
+#ifdef MULTI2_SIMD
+	InstructionType Instruction
+#endif
+	)
+	: m_bIsSysKeyValid(false)
+	, m_bIsWorkKeyValid(false)
+#ifdef MULTI2_SIMD
+	, m_Instruction(Instruction)
+	, m_pSSE2WorkKeyOdd(NULL)
+	, m_pSSE2WorkKeyEven(NULL)
+#endif
+{
+#ifdef MULTI2_SIMD
+	if (m_Instruction != INSTRUCTION_NORMAL) {
+		Multi2DecoderSIMD::AllocWorkKey(&m_pSSE2WorkKeyOdd, &m_pSSE2WorkKeyEven);
+	}
+	switch (m_Instruction) {
+	default:
+	case INSTRUCTION_NORMAL:
+		m_pDecodeFunc = Multi2DecoderSIMD::Decode;
+		break;
+#ifdef MULTI2_SSE2
+	case INSTRUCTION_SSE2:
+		m_pDecodeFunc = Multi2DecoderSIMD::DecodeSSE2;
+		break;
+#endif
+#ifdef MULTI2_SSSE3
+	case INSTRUCTION_SSSE3:
+		m_pDecodeFunc = Multi2DecoderSIMD::DecodeSSSE3;
+		break;
+#endif
+	}
+#endif
+}
+
+CMulti2Decoder::~CMulti2Decoder(void)
+{
+#ifdef MULTI2_SIMD
+	if (m_Instruction != INSTRUCTION_NORMAL) {
+		Multi2DecoderSIMD::FreeWorkKey(&m_pSSE2WorkKeyOdd, &m_pSSE2WorkKeyEven);
+	}
+#endif
+}
+
+const bool CMulti2Decoder::Initialize(const BYTE *pSystemKey, const BYTE *pInitialCbc)
+{
+	if (!pSystemKey || !pInitialCbc)
+		return false;
+
+	m_bIsSysKeyValid = true;
+	m_bIsWorkKeyValid = false;
+
+	// Descrambling System Keyセット
+	m_SystemKey.SetHexData(pSystemKey);
+
+	// Descrambler CBC Initial Valueセット
+	m_InitialCbc.SetHexData(pInitialCbc);
+
+	return true;
+}
+
+const bool CMulti2Decoder::SetScrambleKey(const BYTE *pScrambleKey)
+{
+	if(!m_bIsSysKeyValid)return false;
+
+	if(!pScrambleKey){
+		// キーが設定されない場合はデコード不能にする(不正な復号による破損防止のため)
+		m_bIsWorkKeyValid = false;
+		return false;
+		}
+
+	// Scramble Key Odd/Even をセットする
+	DATKEY ScrKeyOdd, ScrKeyEven;
+
+	// バイトオーダー変換
+	ScrKeyOdd.SetHexData(&pScrambleKey[0]);
+	ScrKeyEven.SetHexData(&pScrambleKey[8]);
+
+	// キースケジュール
+	KeySchedule(m_WorkKeyOdd, m_SystemKey, ScrKeyOdd);
+	KeySchedule(m_WorkKeyEven, m_SystemKey, ScrKeyEven);
+
+#ifdef MULTI2_SIMD
+	if (m_Instruction != INSTRUCTION_NORMAL) {
+		Multi2DecoderSIMD::SetWorkKey(m_pSSE2WorkKeyOdd, m_WorkKeyOdd);
+		Multi2DecoderSIMD::SetWorkKey(m_pSSE2WorkKeyEven, m_WorkKeyEven);
+	}
+#endif
+
+	m_bIsWorkKeyValid = true;
+
+	return true;
+}
+
+const bool CMulti2Decoder::Decode(BYTE *pData, const DWORD dwSize, const BYTE byScrCtrl) const
+{
+	if(!byScrCtrl)return true;										// スクランブルなし
+	else if(!m_bIsSysKeyValid || !m_bIsWorkKeyValid)return false;	// スクランブルキー未設定
+	else if((byScrCtrl != 2U) && (byScrCtrl != 3U))return false;	// スクランブル制御不正
+
+#ifdef MULTI2_STATISTICS
+	Multi2Statistics.OnDecode(dwSize);
+#endif
+
+	// ワークキー選択
+	const SYSKEY &WorkKey = (byScrCtrl == 3)? m_WorkKeyOdd : m_WorkKeyEven;
+
+#ifdef MULTI2_SIMD
+
+	m_pDecodeFunc(pData, dwSize,
+				  &WorkKey,
+				  (byScrCtrl == 3) ? m_pSSE2WorkKeyOdd : m_pSSE2WorkKeyEven,
+				  &m_InitialCbc);
+
+#else	// MULTI2_SIMD
+
+	DATKEY CbcData = m_InitialCbc;
+	//DWORD RemainSize = dwSize / sizeof(DATKEY) * sizeof(DATKEY);
+	DWORD RemainSize = dwSize & 0xFFFFFFF8UL;
+	BYTE *pEnd = pData + RemainSize;
+	BYTE *p = pData;
+
+	// CBCモード
+	DATKEY SrcData;
+	while (p < pEnd) {
+		SrcData.SetHexData(p);
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi4(SrcData, WorkKey.dwKey8);
+			RoundFuncPi3(SrcData, WorkKey.dwKey6, WorkKey.dwKey7);
+			RoundFuncPi2(SrcData, WorkKey.dwKey5);
+			RoundFuncPi1(SrcData);
+			RoundFuncPi4(SrcData, WorkKey.dwKey4);
+			RoundFuncPi3(SrcData, WorkKey.dwKey2, WorkKey.dwKey3);
+			RoundFuncPi2(SrcData, WorkKey.dwKey1);
+			RoundFuncPi1(SrcData);
+		}
+		SrcData ^= CbcData;
+		CbcData.SetHexData(p);
+		SrcData.GetHexData(p);
+		p += sizeof(DATKEY);
+	}
+
+	// OFBモード
+	//RemainSize = dwSize % sizeof(DATKEY);
+	RemainSize = dwSize & 0x00000007UL;
+	if (RemainSize > 0) {
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi1(CbcData);
+			RoundFuncPi2(CbcData, WorkKey.dwKey1);
+			RoundFuncPi3(CbcData, WorkKey.dwKey2, WorkKey.dwKey3);
+			RoundFuncPi4(CbcData, WorkKey.dwKey4);
+			RoundFuncPi1(CbcData);
+			RoundFuncPi2(CbcData, WorkKey.dwKey5);
+			RoundFuncPi3(CbcData, WorkKey.dwKey6, WorkKey.dwKey7);
+			RoundFuncPi4(CbcData, WorkKey.dwKey8);
+		}
+
+		BYTE Remain[sizeof(DATKEY)];
+		CbcData.GetHexData(Remain);
+#if 0
+		pEnd += RemainSize;
+		for (BYTE *q = Remain ; p < pEnd ; q++) {
+			*p++ ^= *q;
+		}
+#else
+		switch (RemainSize) {
+		default: __assume(0);
+		case 7: p[6] ^= Remain[6];
+		case 6: p[5] ^= Remain[5];
+		case 5: p[4] ^= Remain[4];
+		case 4: p[3] ^= Remain[3];
+		case 3: p[2] ^= Remain[2];
+		case 2: p[1] ^= Remain[1];
+		case 1: p[0] ^= Remain[0];
+		}
+#endif
+	}
+
+#endif	// MULTI2_SIMD
+
+	return true;
+}
+
+void CMulti2Decoder::KeySchedule(SYSKEY &WorkKey, const SYSKEY &SysKey, DATKEY &DataKey)
+{
+	// Key Schedule
+	RoundFuncPi1(DataKey);									// π1
+
+	RoundFuncPi2(DataKey, SysKey.dwKey1);					// π2
+	WorkKey.dwKey1 = DataKey.dwLeft;
+
+	RoundFuncPi3(DataKey, SysKey.dwKey2, SysKey.dwKey3);	// π3
+	WorkKey.dwKey2 = DataKey.dwRight;
+
+	RoundFuncPi4(DataKey, SysKey.dwKey4);					// π4
+	WorkKey.dwKey3 = DataKey.dwLeft;
+
+	RoundFuncPi1(DataKey);									// π1
+	WorkKey.dwKey4 = DataKey.dwRight;
+
+	RoundFuncPi2(DataKey, SysKey.dwKey5);					// π2
+	WorkKey.dwKey5 = DataKey.dwLeft;
+
+	RoundFuncPi3(DataKey, SysKey.dwKey6, SysKey.dwKey7);	// π3
+	WorkKey.dwKey6 = DataKey.dwRight;
+
+	RoundFuncPi4(DataKey, SysKey.dwKey8);					// π4
+	WorkKey.dwKey7 = DataKey.dwLeft;
+
+	RoundFuncPi1(DataKey);									// π1
+	WorkKey.dwKey8 = DataKey.dwRight;
+}
+
+inline void CMulti2Decoder::RoundFuncPi1(DATKEY &Block)
+{
+	// Elementary Encryption Function π1
+	Block.dwRight ^= Block.dwLeft;
+}
+
+inline void CMulti2Decoder::RoundFuncPi2(DATKEY &Block, const DWORD dwK1)
+{
+	// Elementary Encryption Function π2
+	const DWORD dwY = Block.dwRight + dwK1;
+	const DWORD dwZ = LeftRotate(dwY, 1UL) + dwY - 1UL;
+	Block.dwLeft ^= LeftRotate(dwZ, 4UL) ^ dwZ;
+}
+
+inline void CMulti2Decoder::RoundFuncPi3(DATKEY &Block, const DWORD dwK2, const DWORD dwK3)
+{
+	// Elementary Encryption Function π3
+	const DWORD dwY = Block.dwLeft + dwK2;
+	const DWORD dwZ = LeftRotate(dwY, 2UL) + dwY + 1UL;
+	const DWORD dwA = LeftRotate(dwZ, 8UL) ^ dwZ;
+	const DWORD dwB = dwA + dwK3;
+	const DWORD dwC = LeftRotate(dwB, 1UL) - dwB;
+	Block.dwRight ^= (LeftRotate(dwC, 16UL) ^ (dwC | Block.dwLeft));
+}
+
+inline void CMulti2Decoder::RoundFuncPi4(DATKEY &Block, const DWORD dwK4)
+{
+	// Elementary Encryption Function π4
+	const DWORD dwY = Block.dwRight + dwK4;
+	Block.dwLeft ^= (LeftRotate(dwY, 2UL) + dwY + 1UL);
+}
+
+inline const DWORD CMulti2Decoder::LeftRotate(const DWORD dwValue, const DWORD dwRotate)
+{
+	// 左ローテート
+#ifndef MULTI2_USE_INTRINSIC
+	return (dwValue << dwRotate) | (dwValue >> (32UL - dwRotate));
+#else
+	// 実は上のコードでもrolが使われる
+	return _lrotl(dwValue, dwRotate);
+#endif
+}
+
+
+#ifdef MULTI2_SIMD
+
+bool CMulti2Decoder::IsSSE2Available()
+{
+	return Multi2DecoderSIMD::IsSSE2Available();
+}
+
+bool CMulti2Decoder::IsSSSE3Available()
+{
+	return Multi2DecoderSIMD::IsSSSE3Available();
+}
+
+#endif	// MULTI2_SIMD
diff -ruN a/TSTask/BonTsEngine/Multi2Decoder.h b/TSTask/BonTsEngine/Multi2Decoder.h
--- a/TSTask/BonTsEngine/Multi2Decoder.h	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/Multi2Decoder.h	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,125 @@
+// Multi2Decoder.h: CMulti2Decoder クラスのインターフェイス
+//
+//////////////////////////////////////////////////////////////////////
+
+#pragma once
+
+
+#define MULTI2_USE_INTRINSIC	// 組み込み関数を利用
+#define MULTI2_SIMD				// SIMD対応
+
+#ifdef MULTI2_SIMD
+/*
+	ICCを使用しない場合は、MULTI2_SIMD_ICCを定義しないようにする
+	(ただし20%ぐらい遅くなる)
+*/
+#define MULTI2_SSE2				// SSE2対応
+#define MULTI2_SSSE3			// SSSE3対応
+//#define MULTI2_SIMD_ICC			// Intel C++ Compiler を利用する
+
+namespace Multi2DecoderSIMD {
+	struct WORKKEY;
+};
+#endif	// MULTI2_SIMD
+
+
+class CMulti2Decoder
+{
+public:
+#ifdef MULTI2_SIMD
+	enum InstructionType
+	{
+		INSTRUCTION_NORMAL,
+		INSTRUCTION_SSE2,
+		INSTRUCTION_SSSE3
+	};
+#endif
+
+	CMulti2Decoder(
+#ifdef MULTI2_SIMD
+		InstructionType Instruction
+#endif
+		);
+	~CMulti2Decoder(void);
+
+	const bool Initialize(const BYTE *pSystemKey, const BYTE *pInitialCbc);
+	const bool SetScrambleKey(const BYTE *pScrambleKey);
+	const bool Decode(BYTE *pData, const DWORD dwSize, const BYTE byScrCtrl) const;
+
+#ifdef MULTI2_SIMD
+	static bool IsSSE2Available();
+	static bool IsSSSE3Available();
+#endif
+
+	class SYSKEY	// System Key(Sk), Expanded Key(Wk) 256bit
+	{
+	public:
+		inline void SetHexData(const BYTE *pHexData);
+		inline void GetHexData(BYTE *pHexData) const;
+
+		union {
+#if !defined(MULTI2_USE_INTRINSIC) || !defined(_WIN64)
+			struct {
+				DWORD dwKey1, dwKey2, dwKey3, dwKey4, dwKey5, dwKey6, dwKey7, dwKey8;
+			};
+#else
+			struct {
+				DWORD dwKey2, dwKey1, dwKey4, dwKey3, dwKey6, dwKey5, dwKey8, dwKey7;
+			};
+			unsigned __int64 Data64[4];
+#endif
+			BYTE Data[32];
+		};
+	};
+
+	class DATKEY	// Data Key(Dk) 64bit
+	{
+	public:
+		inline void SetHexData(const BYTE *pHexData);
+		inline void GetHexData(BYTE *pHexData) const;
+		DATKEY &operator^=(const DATKEY &Operand) {
+#ifndef _WIN64
+			dwRight ^= Operand.dwRight;
+			dwLeft ^= Operand.dwLeft;
+#else
+			Data64 ^= Operand.Data64;
+#endif
+			return *this;
+		}
+
+		union {
+			struct {
+				DWORD dwRight, dwLeft;
+			};
+			unsigned __int64 Data64;
+			BYTE Data[8];
+		};
+	};
+
+private:
+	static void KeySchedule(SYSKEY &WorkKey, const SYSKEY &SysKey, DATKEY &DataKey);
+
+	static inline void RoundFuncPi1(DATKEY &Block);
+	static inline void RoundFuncPi2(DATKEY &Block, const DWORD dwK1);
+	static inline void RoundFuncPi3(DATKEY &Block, const DWORD dwK2, const DWORD dwK3);
+	static inline void RoundFuncPi4(DATKEY &Block, const DWORD dwK4);
+
+	static inline const DWORD LeftRotate(const DWORD dwValue, const DWORD dwRotate);
+
+	DATKEY m_InitialCbc;
+	SYSKEY m_SystemKey;
+	SYSKEY m_WorkKeyOdd, m_WorkKeyEven;
+
+	bool m_bIsSysKeyValid;
+	bool m_bIsWorkKeyValid;
+
+#ifdef MULTI2_SIMD
+	InstructionType m_Instruction;
+	typedef void (*DecodeFunc)(BYTE * __restrict pData, const DWORD dwSize,
+							   const SYSKEY * __restrict pWorkKey,
+							   const Multi2DecoderSIMD::WORKKEY * __restrict pPackedWorkKey,
+							   const DATKEY * __restrict pInitialCbc);
+	DecodeFunc m_pDecodeFunc;
+	Multi2DecoderSIMD::WORKKEY *m_pSSE2WorkKeyOdd, *m_pSSE2WorkKeyEven;
+#endif
+};
diff -ruN a/TSTask/BonTsEngine/Multi2DecoderSIMD.cpp b/TSTask/BonTsEngine/Multi2DecoderSIMD.cpp
--- a/TSTask/BonTsEngine/Multi2DecoderSIMD.cpp	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/Multi2DecoderSIMD.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,973 @@
+#include <windows.h>
+#include "Multi2Decoder.h"
+#include <intrin.h>
+#include <emmintrin.h>
+#ifdef MULTI2_SSSE3
+#include <tmmintrin.h>
+#endif
+#include "Multi2DecoderSIMD.h"
+
+
+// パイプライン向け最適化
+#define MULTI2_OPTIMIZE_FOR_PIPELINE
+
+
+namespace Multi2DecoderSIMD
+{
+
+struct WORKKEY {
+	__m128i Key[8];
+};
+
+#ifndef SCRAMBLE_ROUND
+#define SCRAMBLE_ROUND 4
+#endif
+
+#define MM_SHUFFLE4(a, b, c, d) (((a) << 6) | ((b) << 4) | ((c) << 2) | (d))
+
+//#define IMMEDIATE1 Immediate1
+#define IMMEDIATE1 _mm_set1_epi32(1)
+
+
+//static __m128i Immediate1;
+
+#ifdef MULTI2_SSSE3
+static __m128i ByteSwapMask;
+static __m128i SrcSwapMask;
+static __m128i Rotate16Mask;
+static __m128i Rotate8Mask;
+#endif
+
+
+bool IsSSE2Available()
+{
+#if defined(_M_IX86)
+	bool b;
+
+	__asm {
+		mov		eax, 1
+		cpuid
+		bt		edx, 26
+		setc	b
+	}
+
+	return b;
+#elif defined(_M_AMD64) || defined(_M_X64)
+	return true;
+#else
+	return ::IsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE) != FALSE;
+#endif
+}
+
+
+bool IsSSSE3Available()
+{
+	int Info[4];
+
+	__cpuid(Info, 1);
+	if (Info[2] & 0x200)	// bt ecx, 9
+		return true;
+
+	return false;
+}
+
+
+bool Initialize()
+{
+	if (!IsSSE2Available())
+		return false;
+
+	//Immediate1 = _mm_set1_epi32(1);
+
+#ifdef MULTI2_SSSE3
+	if (IsSSSE3Available()) {
+		ByteSwapMask = _mm_set_epi8(12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3);
+		SrcSwapMask  = _mm_set_epi8(12, 13, 14, 15, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3);
+		Rotate16Mask = _mm_set_epi8(13, 12, 15, 14, 9, 8, 11, 10, 5, 4, 7, 6, 1, 0, 3, 2);
+		Rotate8Mask  = _mm_set_epi8(14, 13, 12, 15, 10, 9, 8, 11, 6, 5, 4, 7, 2, 1, 0, 3);
+	}
+#endif
+
+	return true;
+}
+
+
+void AllocWorkKey(WORKKEY **ppWorkKeyOdd, WORKKEY **ppWorkKeyEven)
+{
+	*ppWorkKeyOdd  = (WORKKEY*)_mm_malloc(sizeof(WORKKEY) * 2, 16);
+	*ppWorkKeyEven = *ppWorkKeyOdd + 1;
+}
+
+
+void FreeWorkKey(WORKKEY **ppWorkKeyOdd, WORKKEY **ppWorkKeyEven)
+{
+	if (*ppWorkKeyOdd) {
+		_mm_free(*ppWorkKeyOdd);
+		*ppWorkKeyOdd  = NULL;
+		*ppWorkKeyEven = NULL;
+	}
+}
+
+
+void SetWorkKey(WORKKEY *pWorkKey, const CMulti2Decoder::SYSKEY &SrcKey)
+{
+	pWorkKey->Key[0] = _mm_set1_epi32(SrcKey.dwKey1);
+	pWorkKey->Key[1] = _mm_set1_epi32(SrcKey.dwKey2);
+	pWorkKey->Key[2] = _mm_set1_epi32(SrcKey.dwKey3);
+	pWorkKey->Key[3] = _mm_set1_epi32(SrcKey.dwKey4);
+	pWorkKey->Key[4] = _mm_set1_epi32(SrcKey.dwKey5);
+	pWorkKey->Key[5] = _mm_set1_epi32(SrcKey.dwKey6);
+	pWorkKey->Key[6] = _mm_set1_epi32(SrcKey.dwKey7);
+	pWorkKey->Key[7] = _mm_set1_epi32(SrcKey.dwKey8);
+}
+
+
+static __forceinline const DWORD LeftRotate(const DWORD dwValue, const DWORD dwRotate)
+{
+	return _lrotl(dwValue, dwRotate);
+}
+
+static __forceinline void RoundFuncPi1(DWORD &Left, DWORD &Right)
+{
+	// Elementary Encryption Function π1
+	Right ^= Left;
+}
+
+static __forceinline void RoundFuncPi2(DWORD &Left, DWORD &Right, const DWORD dwK1)
+{
+	// Elementary Encryption Function π2
+	const DWORD dwY = Right + dwK1;
+	const DWORD dwZ = LeftRotate(dwY, 1UL) + dwY - 1UL;
+	Left ^= LeftRotate(dwZ, 4UL) ^ dwZ;
+}
+
+static __forceinline void RoundFuncPi3(DWORD &Left, DWORD &Right, const DWORD dwK2, const DWORD dwK3)
+{
+	// Elementary Encryption Function π3
+	const DWORD dwY = Left + dwK2;
+	const DWORD dwZ = LeftRotate(dwY, 2UL) + dwY + 1UL;
+	const DWORD dwA = LeftRotate(dwZ, 8UL) ^ dwZ;
+	const DWORD dwB = dwA + dwK3;
+	const DWORD dwC = LeftRotate(dwB, 1UL) - dwB;
+	Right ^= (LeftRotate(dwC, 16UL) ^ (dwC | Left));
+}
+
+static __forceinline void RoundFuncPi4(DWORD &Left, DWORD &Right, const DWORD dwK4)
+{
+	// Elementary Encryption Function π4
+	const DWORD dwY = Right + dwK4;
+	Left ^= (LeftRotate(dwY, 2UL) + dwY + 1UL);
+}
+
+
+void Decode(BYTE * __restrict pData, const DWORD dwSize,
+			const CMulti2Decoder::SYSKEY * __restrict pWorkKey,
+			const WORKKEY * __restrict pPackedWorkKey,
+			const CMulti2Decoder::DATKEY * __restrict pInitialCbc)
+{
+	__assume(dwSize <= 184);
+
+	BYTE * __restrict p = pData;
+	DWORD CbcLeft = pInitialCbc->dwLeft, CbcRight = pInitialCbc->dwRight;
+
+	for (BYTE *pEnd = p + (dwSize & 0xFFFFFFF8UL); p < pEnd; p += 8) {
+		DWORD Src1, Src2, Left, Right;
+
+		Src1 = _byteswap_ulong(*(DWORD*)(p + 0));
+		Src2 = _byteswap_ulong(*(DWORD*)(p + 4));
+		Left  = Src1;
+		Right = Src2;
+
+#if defined(__INTEL_COMPILER) && SCRAMBLE_ROUND <= 4
+#pragma unroll(4)
+#endif
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi4(Left, Right, pWorkKey->dwKey8);
+			RoundFuncPi3(Left, Right, pWorkKey->dwKey6, pWorkKey->dwKey7);
+			RoundFuncPi2(Left, Right, pWorkKey->dwKey5);
+			RoundFuncPi1(Left, Right);
+			RoundFuncPi4(Left, Right, pWorkKey->dwKey4);
+			RoundFuncPi3(Left, Right, pWorkKey->dwKey2, pWorkKey->dwKey3);
+			RoundFuncPi2(Left, Right, pWorkKey->dwKey1);
+			RoundFuncPi1(Left, Right);
+		}
+
+		*(DWORD*)(p + 0) = _byteswap_ulong(Left  ^ CbcLeft);
+		*(DWORD*)(p + 4) = _byteswap_ulong(Right ^ CbcRight);
+		CbcLeft  = Src1;
+		CbcRight = Src2;
+	}
+
+	// OFBモード
+	DWORD RemainSize = dwSize & 0x00000007UL;
+	if (RemainSize) {
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi1(CbcLeft, CbcRight);
+			RoundFuncPi2(CbcLeft, CbcRight, pWorkKey->dwKey1);
+			RoundFuncPi3(CbcLeft, CbcRight, pWorkKey->dwKey2, pWorkKey->dwKey3);
+			RoundFuncPi4(CbcLeft, CbcRight, pWorkKey->dwKey4);
+			RoundFuncPi1(CbcLeft, CbcRight);
+			RoundFuncPi2(CbcLeft, CbcRight, pWorkKey->dwKey5);
+			RoundFuncPi3(CbcLeft, CbcRight, pWorkKey->dwKey6, pWorkKey->dwKey7);
+			RoundFuncPi4(CbcLeft, CbcRight, pWorkKey->dwKey8);
+		}
+
+		BYTE Remain[8];
+		*(DWORD*)(Remain + 0) = CbcLeft;
+		*(DWORD*)(Remain + 4) = CbcRight;
+		switch (RemainSize) {
+		default: __assume(0);
+		case 7: p[6] ^= Remain[5];
+		case 6: p[5] ^= Remain[6];
+		case 5: p[4] ^= Remain[7];
+		case 4: p[3] ^= Remain[0];
+		case 3: p[2] ^= Remain[1];
+		case 2: p[1] ^= Remain[2];
+		case 1: p[0] ^= Remain[3];
+		}
+	}
+}
+
+
+static __forceinline __m128i LeftRotate(const __m128i &Value, const int Rotate)
+{
+	return _mm_or_si128(_mm_slli_epi32(Value, Rotate), _mm_srli_epi32(Value, 32 - Rotate));
+}
+
+static __forceinline __m128i ByteSwapSSE2(const __m128i &Value)
+{
+	__m128i t0 = _mm_srli_epi16(Value, 8);
+	__m128i t1 = _mm_slli_epi16(Value, 8);
+	return LeftRotate(_mm_or_si128(t0, t1), 16);
+}
+
+static __forceinline void RoundFuncPi1SSE2(__m128i &Left, __m128i &Right)
+{
+	Right = _mm_xor_si128(Right, Left);
+}
+
+static __forceinline void RoundFuncPi2SSE2(__m128i &Left, __m128i &Right, const __m128i &Key1)
+{
+	__m128i t;
+
+	t = _mm_add_epi32(Right, Key1);
+	t = _mm_sub_epi32(_mm_add_epi32(LeftRotate(t, 1), t), IMMEDIATE1);
+	t = _mm_xor_si128(LeftRotate(t, 4), t);
+
+	Left = _mm_xor_si128(Left, t);
+}
+
+static __forceinline void RoundFuncPi3SSE2(__m128i &Left, __m128i &Right, const __m128i &Key2, const __m128i &Key3)
+{
+	__m128i t;
+
+	t = _mm_add_epi32(Left, Key2);
+	t = _mm_add_epi32(_mm_add_epi32(LeftRotate(t, 2), t), IMMEDIATE1);
+	t = _mm_xor_si128(LeftRotate(t, 8), t);
+	t = _mm_add_epi32(t, Key3);
+	t = _mm_sub_epi32(LeftRotate(t, 1), t);
+	t = _mm_xor_si128(LeftRotate(t, 16), _mm_or_si128(t, Left));
+
+	Right = _mm_xor_si128(Right, t);
+}
+
+static __forceinline void RoundFuncPi4SSE2(__m128i &Left, __m128i &Right, const __m128i &Key4)
+{
+	__m128i t;
+
+	t = _mm_add_epi32(Right, Key4);
+	t = _mm_add_epi32(_mm_add_epi32(LeftRotate(t, 2), t), IMMEDIATE1);
+
+	Left = _mm_xor_si128(Left, t);
+}
+
+
+#ifdef MULTI2_OPTIMIZE_FOR_PIPELINE
+
+static __forceinline void RoundFuncPi1SSE2_3(__m128i &Left1, __m128i &Right1,
+											 __m128i &Left2, __m128i &Right2,
+											 __m128i &Left3, __m128i &Right3)
+{
+	Right1 = _mm_xor_si128(Right1, Left1);
+	Right2 = _mm_xor_si128(Right2, Left2);
+	Right3 = _mm_xor_si128(Right3, Left3);
+}
+
+static __forceinline void RoundFuncPi2SSE2_3(__m128i &Left1, __m128i &Right1,
+											 __m128i &Left2, __m128i &Right2,
+											 __m128i &Left3, __m128i &Right3,
+											 const __m128i &Key1)
+{
+	__m128i t1, t2, t3;
+
+	t1 = _mm_add_epi32(Right1, Key1);
+	t2 = _mm_add_epi32(Right2, Key1);
+	t3 = _mm_add_epi32(Right3, Key1);
+	t1 = _mm_add_epi32(LeftRotate(t1, 1), t1);
+	t2 = _mm_add_epi32(LeftRotate(t2, 1), t2);
+	t3 = _mm_add_epi32(LeftRotate(t3, 1), t3);
+	t1 = _mm_sub_epi32(t1, IMMEDIATE1);
+	t2 = _mm_sub_epi32(t2, IMMEDIATE1);
+	t3 = _mm_sub_epi32(t3, IMMEDIATE1);
+	t1 = _mm_xor_si128(LeftRotate(t1, 4), t1);
+	t2 = _mm_xor_si128(LeftRotate(t2, 4), t2);
+	t3 = _mm_xor_si128(LeftRotate(t3, 4), t3);
+	Left1 = _mm_xor_si128(Left1, t1);
+	Left2 = _mm_xor_si128(Left2, t2);
+	Left3 = _mm_xor_si128(Left3, t3);
+}
+
+static __forceinline void RoundFuncPi3SSE2_3(__m128i &Left1, __m128i &Right1,
+											 __m128i &Left2, __m128i &Right2,
+											 __m128i &Left3, __m128i &Right3,
+											 const __m128i &Key2, const __m128i &Key3)
+{
+	__m128i t1, t2, t3;
+
+	t1 = _mm_add_epi32(Left1, Key2);
+	t2 = _mm_add_epi32(Left2, Key2);
+	t3 = _mm_add_epi32(Left3, Key2);
+	t1 = _mm_add_epi32(LeftRotate(t1, 2), t1);
+	t2 = _mm_add_epi32(LeftRotate(t2, 2), t2);
+	t3 = _mm_add_epi32(LeftRotate(t3, 2), t3);
+	t1 = _mm_add_epi32(t1, IMMEDIATE1);
+	t2 = _mm_add_epi32(t2, IMMEDIATE1);
+	t3 = _mm_add_epi32(t3, IMMEDIATE1);
+	t1 = _mm_xor_si128(LeftRotate(t1, 8), t1);
+	t2 = _mm_xor_si128(LeftRotate(t2, 8), t2);
+	t3 = _mm_xor_si128(LeftRotate(t3, 8), t3);
+	t1 = _mm_add_epi32(t1, Key3);
+	t2 = _mm_add_epi32(t2, Key3);
+	t3 = _mm_add_epi32(t3, Key3);
+	t1 = _mm_sub_epi32(LeftRotate(t1, 1), t1);
+	t2 = _mm_sub_epi32(LeftRotate(t2, 1), t2);
+	t3 = _mm_sub_epi32(LeftRotate(t3, 1), t3);
+	t1 = _mm_xor_si128(LeftRotate(t1, 16), _mm_or_si128(t1, Left1));
+	t2 = _mm_xor_si128(LeftRotate(t2, 16), _mm_or_si128(t2, Left2));
+	t3 = _mm_xor_si128(LeftRotate(t3, 16), _mm_or_si128(t3, Left3));
+	Right1 = _mm_xor_si128(Right1, t1);
+	Right2 = _mm_xor_si128(Right2, t2);
+	Right3 = _mm_xor_si128(Right3, t3);
+}
+
+static __forceinline void RoundFuncPi4SSE2_3(__m128i &Left1, __m128i &Right1,
+											 __m128i &Left2, __m128i &Right2,
+											 __m128i &Left3, __m128i &Right3,
+											 const __m128i &Key4)
+{
+	__m128i t1, t2, t3;
+
+	t1 = _mm_add_epi32(Right1, Key4);
+	t2 = _mm_add_epi32(Right2, Key4);
+	t3 = _mm_add_epi32(Right3, Key4);
+	t1 = _mm_add_epi32(LeftRotate(t1, 2), t1);
+	t2 = _mm_add_epi32(LeftRotate(t2, 2), t2);
+	t3 = _mm_add_epi32(LeftRotate(t3, 2), t3);
+	t1 = _mm_add_epi32(t1, IMMEDIATE1);
+	t2 = _mm_add_epi32(t2, IMMEDIATE1);
+	t3 = _mm_add_epi32(t3, IMMEDIATE1);
+	Left1 = _mm_xor_si128(Left1, t1);
+	Left2 = _mm_xor_si128(Left2, t2);
+	Left3 = _mm_xor_si128(Left3, t3);
+}
+
+#endif	// MULTI2_OPTIMIZE_FOR_PIPELINE
+
+
+#ifdef MULTI2_SSE2
+
+void DecodeSSE2(BYTE * __restrict pData, const DWORD dwSize,
+				const CMulti2Decoder::SYSKEY * __restrict pWorkKey,
+				const WORKKEY * __restrict pPackedWorkKey,
+				const CMulti2Decoder::DATKEY * __restrict pInitialCbc)
+{
+	__assume(dwSize <= 184);
+
+	BYTE * __restrict p = pData;
+	__m128i Cbc = _mm_set_epi32(0, 0, pInitialCbc->dwRight, pInitialCbc->dwLeft);
+
+	// スクランブル解除するデータのおよそ99%は184バイト
+	if (dwSize == 184) {
+		// 192バイト分処理しているが、パケットデータは余分にメモリを確保してあるので問題ない
+
+#ifndef MULTI2_OPTIMIZE_FOR_PIPELINE
+
+		for (int i = 0; i < 6; i++) {
+			__m128i Src1, Src2, Left, Right;
+
+			// r2 l2 r1 l1
+			Src1 = ByteSwapSSE2(_mm_load_si128((__m128i*)(p +  0)));
+			// r4 l4 r3 l3
+			Src2 = ByteSwapSSE2(_mm_load_si128((__m128i*)(p + 16)));
+
+			// r2 r1 l2 l1
+			__m128i x = _mm_shuffle_epi32(Src1, MM_SHUFFLE4(3, 1, 2, 0));
+			// r4 r3 l4 l3
+			__m128i y = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(3, 1, 2, 0));
+
+			// l4 l3 l2 l1
+			Left  = _mm_unpacklo_epi64(x, y);
+			// r4 r3 r2 r1
+			Right = _mm_unpackhi_epi64(x, y);
+
+#if defined(__INTEL_COMPILER) && SCRAMBLE_ROUND <= 4
+#pragma unroll(4)
+#endif
+			for (int i = 0 ; i < SCRAMBLE_ROUND ; i++) {
+				RoundFuncPi4SSE2(Left, Right, pPackedWorkKey->Key[7]);
+				RoundFuncPi3SSE2(Left, Right, pPackedWorkKey->Key[5], pPackedWorkKey->Key[6]);
+				RoundFuncPi2SSE2(Left, Right, pPackedWorkKey->Key[4]);
+				RoundFuncPi1SSE2(Left, Right);
+				RoundFuncPi4SSE2(Left, Right, pPackedWorkKey->Key[3]);
+				RoundFuncPi3SSE2(Left, Right, pPackedWorkKey->Key[1], pPackedWorkKey->Key[2]);
+				RoundFuncPi2SSE2(Left, Right, pPackedWorkKey->Key[0]);
+				RoundFuncPi1SSE2(Left, Right);
+			}
+
+			// r2 l2 r1 l1
+			x = _mm_unpacklo_epi32(Left, Right);
+			// r4 l4 r3 l3
+			y = _mm_unpackhi_epi32(Left, Right);
+
+			x = _mm_xor_si128(x, _mm_unpacklo_epi64(Cbc, Src1));
+			Cbc = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(1, 0, 3, 2));
+			y = _mm_xor_si128(y, _mm_unpackhi_epi64(Src1, Cbc));
+
+			_mm_store_si128((__m128i*)(p +  0), ByteSwapSSE2(x));
+			_mm_store_si128((__m128i*)(p + 16), ByteSwapSSE2(y));
+
+			p += 32;
+		}
+
+#else	// MULTI2_OPTIMIZE_FOR_PIPELINE
+
+		// パイプラインで処理しやすいように並列化したバージョン
+		for (int i = 0; i < 2; i++) {
+			__m128i Src1, Src2, Src3, Src4, Src5, Src6;
+			__m128i Left1, Right1, Left2, Right2, Left3, Right3;
+			__m128i x1, y1, x2, y2, x3, y3;
+
+			Src1 = _mm_load_si128((__m128i*)(p +  0));
+			Src2 = _mm_load_si128((__m128i*)(p + 16));
+			Src3 = _mm_load_si128((__m128i*)(p + 32));
+			Src4 = _mm_load_si128((__m128i*)(p + 48));
+			Src5 = _mm_load_si128((__m128i*)(p + 64));
+			Src6 = _mm_load_si128((__m128i*)(p + 80));
+
+			Src1 = ByteSwapSSE2(Src1);
+			Src2 = ByteSwapSSE2(Src2);
+			Src3 = ByteSwapSSE2(Src3);
+			Src4 = ByteSwapSSE2(Src4);
+			Src5 = ByteSwapSSE2(Src5);
+			Src6 = ByteSwapSSE2(Src6);
+
+			x1 = _mm_shuffle_epi32(Src1, MM_SHUFFLE4(3, 1, 2, 0));
+			y1 = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(3, 1, 2, 0));
+			x2 = _mm_shuffle_epi32(Src3, MM_SHUFFLE4(3, 1, 2, 0));
+			y2 = _mm_shuffle_epi32(Src4, MM_SHUFFLE4(3, 1, 2, 0));
+			x3 = _mm_shuffle_epi32(Src5, MM_SHUFFLE4(3, 1, 2, 0));
+			y3 = _mm_shuffle_epi32(Src6, MM_SHUFFLE4(3, 1, 2, 0));
+
+			Left1  = _mm_unpacklo_epi64(x1, y1);
+			Right1 = _mm_unpackhi_epi64(x1, y1);
+			Left2  = _mm_unpacklo_epi64(x2, y2);
+			Right2 = _mm_unpackhi_epi64(x2, y2);
+			Left3  = _mm_unpacklo_epi64(x3, y3);
+			Right3 = _mm_unpackhi_epi64(x3, y3);
+
+#if defined(__INTEL_COMPILER) && SCRAMBLE_ROUND <= 4
+#pragma unroll(4)
+#endif
+			for (int i = 0 ; i < SCRAMBLE_ROUND ; i++) {
+				RoundFuncPi4SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[7]);
+				RoundFuncPi3SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3,
+								   pPackedWorkKey->Key[5], pPackedWorkKey->Key[6]);
+				RoundFuncPi2SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[4]);
+				RoundFuncPi1SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3);
+				RoundFuncPi4SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[3]);
+				RoundFuncPi3SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3,
+								   pPackedWorkKey->Key[1], pPackedWorkKey->Key[2]);
+				RoundFuncPi2SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[0]);
+				RoundFuncPi1SSE2_3(Left1, Right1, Left2, Right2, Left3, Right3);
+			}
+
+			x1 = _mm_unpacklo_epi32(Left1, Right1);
+			y1 = _mm_unpackhi_epi32(Left1, Right1);
+			x2 = _mm_unpacklo_epi32(Left2, Right2);
+			y2 = _mm_unpackhi_epi32(Left2, Right2);
+			x3 = _mm_unpacklo_epi32(Left3, Right3);
+			y3 = _mm_unpackhi_epi32(Left3, Right3);
+
+			Src2 = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(1, 0, 3, 2));
+			Src4 = _mm_shuffle_epi32(Src4, MM_SHUFFLE4(1, 0, 3, 2));
+			Src6 = _mm_shuffle_epi32(Src6, MM_SHUFFLE4(1, 0, 3, 2));
+			x1 = _mm_xor_si128(x1, _mm_unpacklo_epi64(Cbc, Src1));
+			y1 = _mm_xor_si128(y1, _mm_unpackhi_epi64(Src1, Src2));
+			x2 = _mm_xor_si128(x2, _mm_unpacklo_epi64(Src2, Src3));
+			y2 = _mm_xor_si128(y2, _mm_unpackhi_epi64(Src3, Src4));
+			x3 = _mm_xor_si128(x3, _mm_unpacklo_epi64(Src4, Src5));
+			y3 = _mm_xor_si128(y3, _mm_unpackhi_epi64(Src5, Src6));
+			Cbc = Src6;
+
+			x1 = ByteSwapSSE2(x1);
+			y1 = ByteSwapSSE2(y1);
+			x2 = ByteSwapSSE2(x2);
+			y2 = ByteSwapSSE2(y2);
+			x3 = ByteSwapSSE2(x3);
+			y3 = ByteSwapSSE2(y3);
+
+			_mm_store_si128((__m128i*)(p +  0), x1);
+			_mm_store_si128((__m128i*)(p + 16), y1);
+			_mm_store_si128((__m128i*)(p + 32), x2);
+			_mm_store_si128((__m128i*)(p + 48), y2);
+			_mm_store_si128((__m128i*)(p + 64), x3);
+			_mm_store_si128((__m128i*)(p + 80), y3);
+
+			p += 32 * 3;
+		}
+
+#endif	// MULTI2_OPTIMIZE_FOR_PIPELINE
+
+		return;
+	}
+
+	// CBCモード
+	for (BYTE *pEnd = p + (dwSize & 0xFFFFFFE0UL); p < pEnd; p += 32) {
+		__m128i Src1, Src2, Left, Right;
+
+		// r2 l2 r1 l1
+		Src1 = ByteSwapSSE2(_mm_loadu_si128((__m128i*)p));
+		// r4 l4 r3 l3
+		Src2 = ByteSwapSSE2(_mm_loadu_si128((__m128i*)(p + 16)));
+
+		// r2 r1 l2 l1
+		__m128i x = _mm_shuffle_epi32(Src1, MM_SHUFFLE4(3, 1, 2, 0));
+		// r4 r3 l4 l3
+		__m128i y = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(3, 1, 2, 0));
+
+		// l4 l3 l2 l1
+		Left  = _mm_unpacklo_epi64(x, y);
+		// r4 r3 r2 r1
+		Right = _mm_unpackhi_epi64(x, y);
+
+		for (int i = 0 ; i < SCRAMBLE_ROUND ; i++) {
+			RoundFuncPi4SSE2(Left, Right, pPackedWorkKey->Key[7]);
+			RoundFuncPi3SSE2(Left, Right, pPackedWorkKey->Key[5], pPackedWorkKey->Key[6]);
+			RoundFuncPi2SSE2(Left, Right, pPackedWorkKey->Key[4]);
+			RoundFuncPi1SSE2(Left, Right);
+			RoundFuncPi4SSE2(Left, Right, pPackedWorkKey->Key[3]);
+			RoundFuncPi3SSE2(Left, Right, pPackedWorkKey->Key[1], pPackedWorkKey->Key[2]);
+			RoundFuncPi2SSE2(Left, Right, pPackedWorkKey->Key[0]);
+			RoundFuncPi1SSE2(Left, Right);
+		}
+
+		// r2 l2 r1 l1
+		x = _mm_unpacklo_epi32(Left, Right);
+		// r4 l4 r3 l3
+		y = _mm_unpackhi_epi32(Left, Right);
+
+#if 0
+		Cbc = _mm_or_si128(_mm_slli_si128(Src1, 8), Cbc);
+		x = _mm_xor_si128(x, Cbc);
+
+		Cbc = _mm_or_si128(_mm_slli_si128(Src2, 8), _mm_srli_si128(Src1, 8));
+		y = _mm_xor_si128(y, Cbc);
+
+		Cbc = _mm_srli_si128(Src2, 8);
+#else
+		x = _mm_xor_si128(x, _mm_unpacklo_epi64(Cbc, Src1));
+		Cbc = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(1, 0, 3, 2));
+		y = _mm_xor_si128(y, _mm_unpackhi_epi64(Src1, Cbc));
+#endif
+
+		_mm_storeu_si128((__m128i*)p,        ByteSwapSSE2(x));
+		_mm_storeu_si128((__m128i*)(p + 16), ByteSwapSSE2(y));
+	}
+
+	DWORD CbcLeft, CbcRight;
+	__declspec(align(16)) DWORD Data[4];
+	_mm_store_si128((__m128i*)Data, Cbc);
+	CbcLeft  = Data[0];
+	CbcRight = Data[1];
+
+	for (BYTE *pEnd = p + (dwSize & 0x00000018UL); p < pEnd; p += 8) {
+		DWORD Src1, Src2, Left, Right;
+
+		Src1 = _byteswap_ulong(*(DWORD*)(p + 0));
+		Src2 = _byteswap_ulong(*(DWORD*)(p + 4));
+		Left  = Src1;
+		Right = Src2;
+
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi4(Left, Right, pWorkKey->dwKey8);
+			RoundFuncPi3(Left, Right, pWorkKey->dwKey6, pWorkKey->dwKey7);
+			RoundFuncPi2(Left, Right, pWorkKey->dwKey5);
+			RoundFuncPi1(Left, Right);
+			RoundFuncPi4(Left, Right, pWorkKey->dwKey4);
+			RoundFuncPi3(Left, Right, pWorkKey->dwKey2, pWorkKey->dwKey3);
+			RoundFuncPi2(Left, Right, pWorkKey->dwKey1);
+			RoundFuncPi1(Left, Right);
+		}
+
+		*(DWORD*)(p + 0) = _byteswap_ulong(Left  ^ CbcLeft);
+		*(DWORD*)(p + 4) = _byteswap_ulong(Right ^ CbcRight);
+		CbcLeft  = Src1;
+		CbcRight = Src2;
+	}
+
+	// OFBモード
+	DWORD RemainSize = dwSize & 0x00000007UL;
+	if (RemainSize) {
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi1(CbcLeft, CbcRight);
+			RoundFuncPi2(CbcLeft, CbcRight, pWorkKey->dwKey1);
+			RoundFuncPi3(CbcLeft, CbcRight, pWorkKey->dwKey2, pWorkKey->dwKey3);
+			RoundFuncPi4(CbcLeft, CbcRight, pWorkKey->dwKey4);
+			RoundFuncPi1(CbcLeft, CbcRight);
+			RoundFuncPi2(CbcLeft, CbcRight, pWorkKey->dwKey5);
+			RoundFuncPi3(CbcLeft, CbcRight, pWorkKey->dwKey6, pWorkKey->dwKey7);
+			RoundFuncPi4(CbcLeft, CbcRight, pWorkKey->dwKey8);
+		}
+
+		BYTE Remain[8];
+		*(DWORD*)(Remain + 0) = CbcLeft;
+		*(DWORD*)(Remain + 4) = CbcRight;
+		switch (RemainSize) {
+		default: __assume(0);
+		case 7: p[6] ^= Remain[5];
+		case 6: p[5] ^= Remain[6];
+		case 5: p[4] ^= Remain[7];
+		case 4: p[3] ^= Remain[0];
+		case 3: p[2] ^= Remain[1];
+		case 2: p[1] ^= Remain[2];
+		case 1: p[0] ^= Remain[3];
+		}
+	}
+}
+
+#endif	// MULTI2_SSE2
+
+
+#ifdef MULTI2_SSSE3
+
+static __forceinline __m128i ByteSwapSSSE3(const __m128i &Value)
+{
+	return _mm_shuffle_epi8(Value, ByteSwapMask);
+}
+
+#define RoundFuncPi1SSSE3 RoundFuncPi1SSE2
+#define RoundFuncPi2SSSE3 RoundFuncPi2SSE2
+#define RoundFuncPi4SSSE3 RoundFuncPi4SSE2
+
+static __forceinline void RoundFuncPi3SSSE3(__m128i &Left, __m128i &Right,
+											const __m128i &Key2, const __m128i &Key3)
+{
+	__m128i t;
+
+	t = _mm_add_epi32(Left, Key2);
+	t = _mm_add_epi32(_mm_add_epi32(LeftRotate(t, 2), t), IMMEDIATE1);
+	t = _mm_xor_si128(_mm_shuffle_epi8(t, Rotate8Mask), t);
+	t = _mm_add_epi32(t, Key3);
+	t = _mm_sub_epi32(LeftRotate(t, 1), t);
+	t = _mm_xor_si128(_mm_shuffle_epi8(t, Rotate16Mask), _mm_or_si128(t, Left));
+
+	Right = _mm_xor_si128(Right, t);
+}
+
+#ifdef MULTI2_OPTIMIZE_FOR_PIPELINE
+
+#define RoundFuncPi1SSSE3_3 RoundFuncPi1SSE2_3
+#define RoundFuncPi2SSSE3_3 RoundFuncPi2SSE2_3
+#define RoundFuncPi4SSSE3_3 RoundFuncPi4SSE2_3
+
+static __forceinline void RoundFuncPi3SSSE3_3(__m128i &Left1, __m128i &Right1,
+											  __m128i &Left2, __m128i &Right2,
+											  __m128i &Left3, __m128i &Right3,
+											  const __m128i &Key2, const __m128i &Key3)
+{
+	__m128i t1, t2, t3;
+
+	t1 = _mm_add_epi32(Left1, Key2);
+	t2 = _mm_add_epi32(Left2, Key2);
+	t3 = _mm_add_epi32(Left3, Key2);
+	t1 = _mm_add_epi32(LeftRotate(t1, 2), t1);
+	t2 = _mm_add_epi32(LeftRotate(t2, 2), t2);
+	t3 = _mm_add_epi32(LeftRotate(t3, 2), t3);
+	t1 = _mm_add_epi32(t1, IMMEDIATE1);
+	t2 = _mm_add_epi32(t2, IMMEDIATE1);
+	t3 = _mm_add_epi32(t3, IMMEDIATE1);
+	t1 = _mm_xor_si128(_mm_shuffle_epi8(t1, Rotate8Mask), t1);
+	t2 = _mm_xor_si128(_mm_shuffle_epi8(t2, Rotate8Mask), t2);
+	t3 = _mm_xor_si128(_mm_shuffle_epi8(t3, Rotate8Mask), t3);
+	t1 = _mm_add_epi32(t1, Key3);
+	t2 = _mm_add_epi32(t2, Key3);
+	t3 = _mm_add_epi32(t3, Key3);
+	t1 = _mm_sub_epi32(LeftRotate(t1, 1), t1);
+	t2 = _mm_sub_epi32(LeftRotate(t2, 1), t2);
+	t3 = _mm_sub_epi32(LeftRotate(t3, 1), t3);
+	t1 = _mm_xor_si128(_mm_shuffle_epi8(t1, Rotate16Mask), _mm_or_si128(t1, Left1));
+	t2 = _mm_xor_si128(_mm_shuffle_epi8(t2, Rotate16Mask), _mm_or_si128(t2, Left2));
+	t3 = _mm_xor_si128(_mm_shuffle_epi8(t3, Rotate16Mask), _mm_or_si128(t3, Left3));
+	Right1 = _mm_xor_si128(Right1, t1);
+	Right2 = _mm_xor_si128(Right2, t2);
+	Right3 = _mm_xor_si128(Right3, t3);
+}
+
+#endif	// MULTI2_OPTIMIZE_FOR_PIPELINE
+
+
+void DecodeSSSE3(BYTE * __restrict pData, const DWORD dwSize,
+				 const CMulti2Decoder::SYSKEY * __restrict pWorkKey,
+				 const WORKKEY * __restrict pPackedWorkKey,
+				 const CMulti2Decoder::DATKEY * __restrict pInitialCbc)
+{
+	__assume(dwSize <= 184);
+
+	BYTE * __restrict p = pData;
+	__m128i Cbc = ByteSwapSSSE3(_mm_set_epi32(0, 0, pInitialCbc->dwRight, pInitialCbc->dwLeft));
+
+	// スクランブル解除するデータのおよそ99%は184バイト
+	if (dwSize == 184) {
+		// 192バイト分処理しているが、パケットデータは余分にメモリを確保してあるので問題ない
+
+#ifndef MULTI2_OPTIMIZE_FOR_PIPELINE
+
+		for (int i = 0; i < 6; i++) {
+			__m128i Src1, Src2, Left, Right, x, y;
+
+			// r2 l2 r1 l1
+			Src1 = _mm_load_si128((__m128i*)(p +  0));
+			// r4 l4 r3 l3
+			Src2 = _mm_load_si128((__m128i*)(p + 16));
+
+			// r2 r1 l2 l1
+			x = _mm_shuffle_epi8(Src1, SrcSwapMask);
+			// r4 r3 l4 l3
+			y = _mm_shuffle_epi8(Src2, SrcSwapMask);
+
+			// l4 l3 l2 l1
+			Left  = _mm_unpacklo_epi64(x, y);
+			// r4 r3 r2 r1
+			Right = _mm_unpackhi_epi64(x, y);
+
+#if defined(__INTEL_COMPILER) && SCRAMBLE_ROUND <= 4
+#pragma unroll(4)
+#endif
+			for (int i = 0 ; i < SCRAMBLE_ROUND ; i++) {
+				RoundFuncPi4SSSE3(Left, Right, pPackedWorkKey->Key[7]);
+				RoundFuncPi3SSSE3(Left, Right, pPackedWorkKey->Key[5], pPackedWorkKey->Key[6]);
+				RoundFuncPi2SSSE3(Left, Right, pPackedWorkKey->Key[4]);
+				RoundFuncPi1SSSE3(Left, Right);
+				RoundFuncPi4SSSE3(Left, Right, pPackedWorkKey->Key[3]);
+				RoundFuncPi3SSSE3(Left, Right, pPackedWorkKey->Key[1], pPackedWorkKey->Key[2]);
+				RoundFuncPi2SSSE3(Left, Right, pPackedWorkKey->Key[0]);
+				RoundFuncPi1SSSE3(Left, Right);
+			}
+
+			// r2 l2 r1 l1
+			x = ByteSwapSSSE3(_mm_unpacklo_epi32(Left, Right));
+			// r4 l4 r3 l3
+			y = ByteSwapSSSE3(_mm_unpackhi_epi32(Left, Right));
+
+			x = _mm_xor_si128(x, _mm_unpacklo_epi64(Cbc, Src1));
+			Cbc = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(1, 0, 3, 2));
+			y = _mm_xor_si128(y, _mm_unpackhi_epi64(Src1, Cbc));
+
+			_mm_store_si128((__m128i*)(p +  0), x);
+			_mm_store_si128((__m128i*)(p + 16), y);
+
+			p += 32;
+		}
+
+#else	// MULTI2_OPTIMIZE_FOR_PIPELINE
+
+		// パイプラインで処理しやすいように並列化したバージョン
+		for (int i = 0; i < 2; i++) {
+			__m128i Src1, Src2, Src3, Src4, Src5, Src6;
+			__m128i Left1, Right1, Left2, Right2, Left3, Right3;
+			__m128i x1, y1, x2, y2, x3, y3;
+
+			Src1 = _mm_load_si128((__m128i*)(p +  0));
+			Src2 = _mm_load_si128((__m128i*)(p + 16));
+			Src3 = _mm_load_si128((__m128i*)(p + 32));
+			Src4 = _mm_load_si128((__m128i*)(p + 48));
+			Src5 = _mm_load_si128((__m128i*)(p + 64));
+			Src6 = _mm_load_si128((__m128i*)(p + 80));
+
+			x1 = _mm_shuffle_epi8(Src1, SrcSwapMask);
+			y1 = _mm_shuffle_epi8(Src2, SrcSwapMask);
+			x2 = _mm_shuffle_epi8(Src3, SrcSwapMask);
+			y2 = _mm_shuffle_epi8(Src4, SrcSwapMask);
+			x3 = _mm_shuffle_epi8(Src5, SrcSwapMask);
+			y3 = _mm_shuffle_epi8(Src6, SrcSwapMask);
+
+			Left1  = _mm_unpacklo_epi64(x1, y1);
+			Right1 = _mm_unpackhi_epi64(x1, y1);
+			Left2  = _mm_unpacklo_epi64(x2, y2);
+			Right2 = _mm_unpackhi_epi64(x2, y2);
+			Left3  = _mm_unpacklo_epi64(x3, y3);
+			Right3 = _mm_unpackhi_epi64(x3, y3);
+
+#if defined(__INTEL_COMPILER) && SCRAMBLE_ROUND <= 4
+#pragma unroll(4)
+#endif
+			for (int i = 0 ; i < SCRAMBLE_ROUND ; i++) {
+				RoundFuncPi4SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[7]);
+				RoundFuncPi3SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3,
+								    pPackedWorkKey->Key[5], pPackedWorkKey->Key[6]);
+				RoundFuncPi2SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[4]);
+				RoundFuncPi1SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3);
+				RoundFuncPi4SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[3]);
+				RoundFuncPi3SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3,
+								    pPackedWorkKey->Key[1], pPackedWorkKey->Key[2]);
+				RoundFuncPi2SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3, pPackedWorkKey->Key[0]);
+				RoundFuncPi1SSSE3_3(Left1, Right1, Left2, Right2, Left3, Right3);
+			}
+
+			x1 = _mm_unpacklo_epi32(Left1, Right1);
+			y1 = _mm_unpackhi_epi32(Left1, Right1);
+			x2 = _mm_unpacklo_epi32(Left2, Right2);
+			y2 = _mm_unpackhi_epi32(Left2, Right2);
+			x3 = _mm_unpacklo_epi32(Left3, Right3);
+			y3 = _mm_unpackhi_epi32(Left3, Right3);
+
+			x1 = ByteSwapSSSE3(x1);
+			y1 = ByteSwapSSSE3(y1);
+			x2 = ByteSwapSSSE3(x2);
+			y2 = ByteSwapSSSE3(y2);
+			x3 = ByteSwapSSSE3(x3);
+			y3 = ByteSwapSSSE3(y3);
+
+			Src2 = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(1, 0, 3, 2));
+			Src4 = _mm_shuffle_epi32(Src4, MM_SHUFFLE4(1, 0, 3, 2));
+			Src6 = _mm_shuffle_epi32(Src6, MM_SHUFFLE4(1, 0, 3, 2));
+			x1 = _mm_xor_si128(x1, _mm_unpacklo_epi64(Cbc, Src1));
+			y1 = _mm_xor_si128(y1, _mm_unpackhi_epi64(Src1, Src2));
+			x2 = _mm_xor_si128(x2, _mm_unpacklo_epi64(Src2, Src3));
+			y2 = _mm_xor_si128(y2, _mm_unpackhi_epi64(Src3, Src4));
+			x3 = _mm_xor_si128(x3, _mm_unpacklo_epi64(Src4, Src5));
+			y3 = _mm_xor_si128(y3, _mm_unpackhi_epi64(Src5, Src6));
+			Cbc = Src6;
+
+			_mm_store_si128((__m128i*)(p +  0), x1);
+			_mm_store_si128((__m128i*)(p + 16), y1);
+			_mm_store_si128((__m128i*)(p + 32), x2);
+			_mm_store_si128((__m128i*)(p + 48), y2);
+			_mm_store_si128((__m128i*)(p + 64), x3);
+			_mm_store_si128((__m128i*)(p + 80), y3);
+
+			p += 32 * 3;
+		}
+
+#endif	// MULTI2_OPTIMIZE_FOR_PIPELINE
+
+		return;
+	}
+
+	// CBCモード
+	for (BYTE *pEnd = p + (dwSize & 0xFFFFFFE0UL); p < pEnd; p += 32) {
+		__m128i Src1, Src2, Left, Right, x, y;
+
+		// r2 l2 r1 l1
+		Src1 = _mm_loadu_si128((__m128i*)p);
+		// r4 l4 r3 l3
+		Src2 = _mm_loadu_si128((__m128i*)(p + 16));
+
+		// r2 r1 l2 l1
+		x = _mm_shuffle_epi8(Src1, SrcSwapMask);
+		// r4 r3 l4 l3
+		y = _mm_shuffle_epi8(Src2, SrcSwapMask);
+
+		// l4 l3 l2 l1
+		Left  = _mm_unpacklo_epi64(x, y);
+		// r4 r3 r2 r1
+		Right = _mm_unpackhi_epi64(x, y);
+
+		for (int i = 0 ; i < SCRAMBLE_ROUND ; i++) {
+			RoundFuncPi4SSSE3(Left, Right, pPackedWorkKey->Key[7]);
+			RoundFuncPi3SSSE3(Left, Right, pPackedWorkKey->Key[5], pPackedWorkKey->Key[6]);
+			RoundFuncPi2SSSE3(Left, Right, pPackedWorkKey->Key[4]);
+			RoundFuncPi1SSSE3(Left, Right);
+			RoundFuncPi4SSSE3(Left, Right, pPackedWorkKey->Key[3]);
+			RoundFuncPi3SSSE3(Left, Right, pPackedWorkKey->Key[1], pPackedWorkKey->Key[2]);
+			RoundFuncPi2SSSE3(Left, Right, pPackedWorkKey->Key[0]);
+			RoundFuncPi1SSSE3(Left, Right);
+		}
+
+		// r2 l2 r1 l1
+		x = ByteSwapSSSE3(_mm_unpacklo_epi32(Left, Right));
+		// r4 l4 r3 l3
+		y = ByteSwapSSSE3(_mm_unpackhi_epi32(Left, Right));
+
+		x = _mm_xor_si128(x, _mm_unpacklo_epi64(Cbc, Src1));
+		Cbc = _mm_shuffle_epi32(Src2, MM_SHUFFLE4(1, 0, 3, 2));
+		y = _mm_xor_si128(y, _mm_unpackhi_epi64(Src1, Cbc));
+
+		_mm_storeu_si128((__m128i*)p,        x);
+		_mm_storeu_si128((__m128i*)(p + 16), y);
+	}
+
+	DWORD CbcLeft, CbcRight;
+	__declspec(align(16)) DWORD Data[4];
+	_mm_store_si128((__m128i*)Data, ByteSwapSSSE3(Cbc));
+	CbcLeft  = Data[0];
+	CbcRight = Data[1];
+
+	for (BYTE *pEnd = p + (dwSize & 0x00000018UL); p < pEnd; p += 8) {
+		DWORD Src1, Src2, Left, Right;
+
+		Src1 = _byteswap_ulong(*(DWORD*)(p + 0));
+		Src2 = _byteswap_ulong(*(DWORD*)(p + 4));
+		Left  = Src1;
+		Right = Src2;
+
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi4(Left, Right, pWorkKey->dwKey8);
+			RoundFuncPi3(Left, Right, pWorkKey->dwKey6, pWorkKey->dwKey7);
+			RoundFuncPi2(Left, Right, pWorkKey->dwKey5);
+			RoundFuncPi1(Left, Right);
+			RoundFuncPi4(Left, Right, pWorkKey->dwKey4);
+			RoundFuncPi3(Left, Right, pWorkKey->dwKey2, pWorkKey->dwKey3);
+			RoundFuncPi2(Left, Right, pWorkKey->dwKey1);
+			RoundFuncPi1(Left, Right);
+		}
+
+		*(DWORD*)(p + 0) = _byteswap_ulong(Left  ^ CbcLeft);
+		*(DWORD*)(p + 4) = _byteswap_ulong(Right ^ CbcRight);
+		CbcLeft  = Src1;
+		CbcRight = Src2;
+	}
+
+	// OFBモード
+	DWORD RemainSize = dwSize & 0x00000007UL;
+	if (RemainSize) {
+		for (int Round = 0 ; Round < SCRAMBLE_ROUND ; Round++) {
+			RoundFuncPi1(CbcLeft, CbcRight);
+			RoundFuncPi2(CbcLeft, CbcRight, pWorkKey->dwKey1);
+			RoundFuncPi3(CbcLeft, CbcRight, pWorkKey->dwKey2, pWorkKey->dwKey3);
+			RoundFuncPi4(CbcLeft, CbcRight, pWorkKey->dwKey4);
+			RoundFuncPi1(CbcLeft, CbcRight);
+			RoundFuncPi2(CbcLeft, CbcRight, pWorkKey->dwKey5);
+			RoundFuncPi3(CbcLeft, CbcRight, pWorkKey->dwKey6, pWorkKey->dwKey7);
+			RoundFuncPi4(CbcLeft, CbcRight, pWorkKey->dwKey8);
+		}
+
+		BYTE Remain[8];
+		*(DWORD*)(Remain + 0) = CbcLeft;
+		*(DWORD*)(Remain + 4) = CbcRight;
+		switch (RemainSize) {
+		default: __assume(0);
+		case 7: p[6] ^= Remain[5];
+		case 6: p[5] ^= Remain[6];
+		case 5: p[4] ^= Remain[7];
+		case 4: p[3] ^= Remain[0];
+		case 3: p[2] ^= Remain[1];
+		case 2: p[1] ^= Remain[2];
+		case 1: p[0] ^= Remain[3];
+		}
+	}
+}
+
+#endif	// MULTI2_SSSE3
+
+}	// namespace Multi2DecoderSIMD
diff -ruN a/TSTask/BonTsEngine/Multi2DecoderSIMD.h b/TSTask/BonTsEngine/Multi2DecoderSIMD.h
--- a/TSTask/BonTsEngine/Multi2DecoderSIMD.h	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/Multi2DecoderSIMD.h	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,38 @@
+#ifndef MULTI2_DECODER_SIMD
+#define MULTI2_DECODER_SIMD
+
+
+namespace Multi2DecoderSIMD
+{
+
+	struct WORKKEY;
+
+	bool IsSSE2Available();
+	bool IsSSSE3Available();
+	bool Initialize();
+
+	void AllocWorkKey(WORKKEY **ppWorkKeyOdd, WORKKEY **ppWorkKeyEven);
+	void FreeWorkKey(WORKKEY **ppWorkKeyOdd, WORKKEY **ppWorkKeyEven);
+	void SetWorkKey(WORKKEY *pWorkKey, const CMulti2Decoder::SYSKEY &SrcKey);
+
+	void Decode(BYTE * __restrict pData, const DWORD dwSize,
+				const CMulti2Decoder::SYSKEY * __restrict pWorkKey,
+				const WORKKEY * __restrict pPackedWorkKey,
+				const CMulti2Decoder::DATKEY * __restrict pInitialCbc);
+#ifdef MULTI2_SSE2
+	void DecodeSSE2(BYTE * __restrict pData, const DWORD dwSize,
+					const CMulti2Decoder::SYSKEY * __restrict pWorkKey,
+					const WORKKEY * __restrict pPackedWorkKey,
+					const CMulti2Decoder::DATKEY * __restrict pInitialCbc);
+#endif
+#ifdef MULTI2_SSSE3
+	void DecodeSSSE3(BYTE * __restrict pData, const DWORD dwSize,
+					 const CMulti2Decoder::SYSKEY * __restrict pWorkKey,
+					 const WORKKEY * __restrict pPackedWorkKey,
+					 const CMulti2Decoder::DATKEY * __restrict pInitialCbc);
+#endif
+
+}	// namespace Multi2DecoderSIMD
+
+
+#endif
diff -ruN a/TSTask/BonTsEngine/TsDescrambler.cpp b/TSTask/BonTsEngine/TsDescrambler.cpp
--- a/TSTask/BonTsEngine/TsDescrambler.cpp	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/TsDescrambler.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,1598 @@
+// TsDescrambler.cpp: CTsDescrambler クラスのインプリメンテーション
+//
+//////////////////////////////////////////////////////////////////////
+
+#include "stdafx.h"
+#include "Common.h"
+#include "TsDescrambler.h"
+#include "Multi2Decoder.h"
+#include "TsEncode.h"
+
+#ifdef _DEBUG
+#undef THIS_FILE
+static char THIS_FILE[]=__FILE__;
+#define new DEBUG_NEW
+#endif
+
+#pragma intrinsic(memcmp)
+
+
+// EMM処理を行う期間
+#define EMM_PROCESS_TIME	(7 * 24)
+
+
+// ECM処理内部クラス
+class CEcmProcessor
+	: public CPsiSingleTable
+	, public CDynamicReferenceable
+{
+public:
+	CEcmProcessor(CTsDescrambler *pDescrambler);
+	const bool DescramblePacket(CTsPacket *pTsPacket);
+	const bool SetScrambleKey(CCasCard *pCasCard, const BYTE *pEcmData, DWORD EcmSize);
+
+	static void ResetCardReaderStatus() { m_bCardReaderHung = false; }
+
+private:
+// CTsPidMapTarget
+	void OnPidMapped(const WORD wPID, const PVOID pParam) override;
+	void OnPidUnmapped(const WORD wPID) override;
+
+// CPsiSingleTable
+	const bool OnTableUpdate(const CPsiSection *pCurSection, const CPsiSection *pOldSection) override;
+
+// CEcmProcessor
+	void OnCardReaderHung();
+
+	CTsDescrambler *m_pDescrambler;
+	CMulti2Decoder m_Multi2Decoder;
+	WORD m_EcmPID;
+	CLocalEvent m_EcmProcessEvent;
+	CCriticalLock m_Multi2Lock;
+
+	bool m_bEcmReceived;
+	bool m_bLastEcmSucceed;
+	bool m_bOddKeyValid;
+	bool m_bEvenKeyValid;
+	int m_LastChangedKey;
+	bool m_bEcmErrorSent;
+	BYTE m_LastScramblingCtrl;
+	BYTE m_LastKsData[16];
+
+	static DWORD m_EcmErrorCount;
+	static bool m_bCardReaderHung;
+};
+
+// EMM処理内部クラス
+class CEmmProcessor
+	: public CPsiStreamTable
+	, public CDynamicReferenceable
+{
+public:
+	CEmmProcessor(CTsDescrambler *pDescrambler);
+	const bool ProcessEmm(CCasCard *pCasCard, const BYTE *pData, const DWORD DataSize);
+
+private:
+// CTsPidMapTarget
+	void OnPidMapped(const WORD wPID, const PVOID pParam) override;
+	void OnPidUnmapped(const WORD wPID) override;
+
+// CPsiStreamTable
+	const bool OnTableUpdate(const CPsiSection *pCurSection) override;
+
+	CTsDescrambler *m_pDescrambler;
+};
+
+// ESスクランブル解除内部クラス
+class CTsDescrambler::CEsProcessor : public CTsPidMapTarget
+{
+public:
+	CEsProcessor(CEcmProcessor *pEcmProcessor);
+	virtual ~CEsProcessor();
+	const CEcmProcessor *GetEcmProcessor() const { return m_pEcmProcessor; }
+
+private:
+// CTsPidMapTarget
+	const bool StorePacket(const CTsPacket *pPacket) override;
+	void OnPidMapped(const WORD wPID, const PVOID pParam) override;
+	void OnPidUnmapped(const WORD wPID) override;
+
+	CEcmProcessor *m_pEcmProcessor;
+};
+
+class CDescramblePmtTable : public CPmtTable
+{
+	CTsDescrambler *m_pDescrambler;
+	CTsPidMapManager *m_pMapManager;
+	CEcmProcessor *m_pEcmProcessor;
+	WORD m_EcmPID;
+	WORD m_ServiceID;
+	std::vector<WORD> m_EsPIDList;
+
+	void UnmapEcmTarget();
+	void UnmapEsTarget();
+
+// CTsPidMapTarget
+	void OnPidUnmapped(const WORD wPID) override;
+
+public:
+	CDescramblePmtTable(CTsDescrambler *pDescrambler);
+	void SetTarget();
+	void ResetTarget();
+};
+
+class CEcmAccess : public CCasAccess
+{
+	BYTE m_EcmData[MAX_ECM_DATA_SIZE];
+	DWORD m_EcmSize;
+	CEcmProcessor *m_pEcmProcessor;
+	CLocalEvent *m_pEvent;
+
+	// コピー禁止
+	CEcmAccess(const CEcmAccess &Src);
+	CEcmAccess &operator=(const CEcmAccess &Src);
+
+public:
+	CEcmAccess(CEcmProcessor *pEcmProcessor, const BYTE *pData, DWORD Size, CLocalEvent *pEvent)
+		: m_EcmSize(Size)
+		, m_pEcmProcessor(pEcmProcessor)
+		, m_pEvent(pEvent)
+	{
+		::CopyMemory(m_EcmData, pData, Size);
+		m_pEcmProcessor->AddRef();
+	}
+
+	~CEcmAccess()
+	{
+		m_pEvent->Set();
+		m_pEcmProcessor->ReleaseRef();
+	}
+
+	bool Process(CCasCard *pCasCard) override
+	{
+		return m_pEcmProcessor->SetScrambleKey(pCasCard, m_EcmData, m_EcmSize);
+	}
+};
+
+class CEmmAccess : public CCasAccess
+{
+	BYTE m_EmmData[MAX_EMM_DATA_SIZE];
+	DWORD m_EmmSize;
+	CEmmProcessor *m_pEmmProcessor;
+
+	// コピー禁止
+	CEmmAccess(const CEmmAccess &Src);
+	CEmmAccess &operator=(const CEmmAccess &Src);
+
+public:
+	CEmmAccess(CEmmProcessor *pEmmProcessor, const BYTE *pData, DWORD Size)
+		: m_EmmSize(Size)
+		, m_pEmmProcessor(pEmmProcessor)
+	{
+		::CopyMemory(m_EmmData, pData, Size);
+		m_pEmmProcessor->AddRef();
+	}
+
+	~CEmmAccess()
+	{
+		m_pEmmProcessor->ReleaseRef();
+	}
+
+	bool Process(CCasCard *pCasCard) override
+	{
+		return m_pEmmProcessor->ProcessEmm(pCasCard, m_EmmData, m_EmmSize);
+	}
+};
+
+class CConfirmContractAccess : public CCasAccess
+{
+	BYTE m_VerificationInfo[255];
+	BYTE m_VerificationInfoSize;
+	WORD m_Date;
+	CLocalEvent *m_pEvent;
+	bool *m_pbSuccess;
+
+public:
+	CConfirmContractAccess(const BYTE *pVerificationInfo, BYTE VerificationInfoSize, WORD Date,
+						   CLocalEvent *pEvent, bool *pbSuccess)
+		: m_VerificationInfoSize(VerificationInfoSize)
+		, m_Date(Date)
+		, m_pEvent(pEvent)
+		, m_pbSuccess(pbSuccess)
+	{
+		::CopyMemory(m_VerificationInfo, pVerificationInfo, VerificationInfoSize);
+	}
+
+	~CConfirmContractAccess()
+	{
+		if (m_pEvent)
+			m_pEvent->Set();
+	}
+
+	bool Process(CCasCard *pCasCard) override
+	{
+		bool bSuccess = pCasCard->ConfirmContract(m_VerificationInfo, m_VerificationInfoSize, m_Date);
+		if (m_pbSuccess)
+			*m_pbSuccess = bSuccess;
+		return true;
+	}
+};
+
+class CCasSendCommandAccess : public CCasAccess
+{
+	BYTE *m_pSendData;
+	DWORD m_SendSize;
+	BYTE *m_pReceiveData;
+	DWORD *m_pReceiveSize;
+	CLocalEvent *m_pEvent;
+	bool *m_pbSuccess;
+
+public:
+	CCasSendCommandAccess(const BYTE *pSendData, DWORD SendSize,
+						   BYTE *pReceiveData, DWORD *pReceiveSize,
+						   CLocalEvent *pEvent, bool *pbSuccess)
+		: m_SendSize(SendSize)
+		, m_pReceiveData(pReceiveData)
+		, m_pReceiveSize(pReceiveSize)
+		, m_pEvent(pEvent)
+		, m_pbSuccess(pbSuccess)
+	{
+		m_pSendData = new BYTE[SendSize];
+		::CopyMemory(m_pSendData, pSendData, SendSize);
+	}
+
+	~CCasSendCommandAccess()
+	{
+		if (m_pEvent)
+			m_pEvent->Set();
+		delete [] m_pSendData;
+	}
+
+	bool Process(CCasCard *pCasCard) override
+	{
+		bool bSuccess = pCasCard->SendCommand(m_pSendData, m_SendSize, m_pReceiveData, m_pReceiveSize);
+		if (m_pbSuccess)
+			*m_pbSuccess = bSuccess;
+		return true;
+	}
+};
+
+
+//////////////////////////////////////////////////////////////////////
+// CTsDescrambler 構築/消滅
+//////////////////////////////////////////////////////////////////////
+
+CTsDescrambler::CTsDescrambler(IEventHandler *pEventHandler)
+	: CMediaDecoder(pEventHandler, 1UL, 1UL)
+	, m_bDescramble(true)
+	, m_bProcessEmm(false)
+	, m_InputPacketCount(0)
+	, m_ScramblePacketCount(0)
+	, m_CurTransportStreamID(0)
+	, m_DescrambleServiceID(0)
+	, m_Queue(&m_CasCard)
+	, m_Instruction(INSTRUCTION_NORMAL)
+	, m_EmmPID(0xFFFF)
+{
+	if (IsSSSE3Available())
+		m_Instruction = INSTRUCTION_SSSE3;
+	else if (IsSSE2Available())
+		m_Instruction = INSTRUCTION_SSE2;
+
+	Reset();
+}
+
+CTsDescrambler::~CTsDescrambler()
+{
+	CloseCasCard();
+}
+
+void CTsDescrambler::Reset(void)
+{
+	CBlockLock Lock(&m_DecoderLock);
+
+	m_Queue.Clear();
+
+	// 内部状態を初期化する
+	m_PidMapManager.UnmapAllTarget();
+
+	CEcmProcessor::ResetCardReaderStatus();
+
+	// PATテーブルPIDマップ追加
+	m_PidMapManager.MapTarget(PID_PAT, new CPatTable, OnPatUpdated, this);
+
+	// SDTテーブルPIDマップ追加
+	m_PidMapManager.MapTarget(PID_SDT, new CSdtTable, OnSdtUpdated, this);
+
+	if (m_bProcessEmm) {
+		// CATテーブルPIDマップ追加
+		m_PidMapManager.MapTarget(PID_CAT, new CCatTable, OnCatUpdated, this);
+
+		// TOTテーブルPIDマップ追加
+		m_PidMapManager.MapTarget(PID_TOT, new CTotTable);
+	}
+
+	// 統計データ初期化
+	m_InputPacketCount = 0;
+	m_ScramblePacketCount = 0;
+
+	m_CurTransportStreamID = 0;
+
+	// スクランブル解除ターゲット初期化
+	m_DescrambleServiceID = 0;
+	m_ServiceList.clear();
+
+	m_EmmPID = 0xFFFF;
+}
+
+const bool CTsDescrambler::InputMedia(CMediaData *pMediaData, const DWORD dwInputIndex)
+{
+	CBlockLock Lock(&m_DecoderLock);
+
+	/*
+	if(dwInputIndex >= GetInputNum())return false;
+
+	CTsPacket *pTsPacket = dynamic_cast<CTsPacket *>(pMediaData);
+
+	// 入力メディアデータは互換性がない
+	if(!pTsPacket)return false;
+	*/
+
+	CTsPacket *pTsPacket = static_cast<CTsPacket *>(pMediaData);
+
+	// 入力パケット数カウント
+	m_InputPacketCount++;
+
+	if (!pTsPacket->IsScrambled() || m_bDescramble) {
+		// PIDルーティング
+		m_PidMapManager.StorePacket(pTsPacket);
+	} else {
+		// 復号漏れパケット数カウント
+		m_ScramblePacketCount++;
+	}
+
+	// パケットを下流デコーダにデータを渡す
+	OutputMedia(pMediaData);
+
+	return true;
+}
+
+bool CTsDescrambler::EnableDescramble(bool bDescramble)
+{
+	CBlockLock Lock(&m_DecoderLock);
+
+	m_bDescramble = bDescramble;
+	return true;
+}
+
+bool CTsDescrambler::IsDescrambleEnabled() const
+{
+	return m_bDescramble;
+}
+
+bool CTsDescrambler::EnableEmmProcess(bool bEnable)
+{
+	CBlockLock Lock(&m_DecoderLock);
+
+	if (m_bProcessEmm != bEnable) {
+		if (bEnable) {
+			// CATテーブルPIDマップ追加
+			m_PidMapManager.MapTarget(PID_CAT, new CCatTable, OnCatUpdated, this);
+			// TOTテーブルPIDマップ追加
+			m_PidMapManager.MapTarget(PID_TOT, new CTotTable);
+		} else {
+			if (m_EmmPID < 0x1FFF) {
+				m_PidMapManager.UnmapTarget(m_EmmPID);
+				m_EmmPID = 0xFFFF;
+			}
+			m_PidMapManager.UnmapTarget(PID_CAT);
+			m_PidMapManager.UnmapTarget(PID_TOT);
+		}
+		m_bProcessEmm = bEnable;
+	}
+	return true;
+}
+
+bool CTsDescrambler::IsEmmProcessEnabled() const
+{
+	return m_bProcessEmm;
+}
+
+bool CTsDescrambler::OpenCasCard(CCardReader::ReaderType ReaderType, LPCTSTR pszReaderName)
+{
+	CloseCasCard();
+
+	bool bOK = m_Queue.BeginCasThread(ReaderType, pszReaderName);
+
+	CEcmProcessor::ResetCardReaderStatus();
+
+	SetError(m_Queue.GetLastErrorException());
+
+	return bOK;
+}
+
+void CTsDescrambler::CloseCasCard(void)
+{
+	m_Queue.EndCasThread();
+	// CASカードを閉じる
+	//m_CasCard.CloseCard();
+}
+
+bool CTsDescrambler::IsCasCardOpen() const
+{
+	return m_CasCard.IsCardOpen();
+}
+
+CCardReader::ReaderType CTsDescrambler::GetCardReaderType() const
+{
+	return m_CasCard.GetCardReaderType();
+}
+
+LPCTSTR CTsDescrambler::GetCardReaderName() const
+{
+	return m_CasCard.GetCardReaderName();
+}
+
+bool CTsDescrambler::GetCasCardInfo(CCasCard::CasCardInfo *pInfo) const
+{
+	return m_CasCard.GetCasCardInfo(pInfo);
+}
+
+bool CTsDescrambler::GetCasCardID(BYTE *pCardID) const
+{
+	if (pCardID == NULL)
+		return false;
+
+	// カードID取得
+	const BYTE *pBuff = m_CasCard.GetCardID();
+	if (pBuff == NULL)
+		return false;
+
+	// バッファにコピー
+	::CopyMemory(pCardID, pBuff, 6UL);
+
+	return true;
+}
+
+int CTsDescrambler::FormatCasCardID(LPTSTR pszText,int MaxLength) const
+{
+	return m_CasCard.FormatCardID(pszText, MaxLength);
+}
+
+char CTsDescrambler::GetCasCardManufacturerID() const
+{
+	return m_CasCard.GetCardManufacturerID();
+}
+
+BYTE CTsDescrambler::GetCasCardVersion() const
+{
+	return m_CasCard.GetCardVersion();
+}
+
+ULONGLONG CTsDescrambler::GetInputPacketCount(void) const
+{
+	// 入力パケット数を返す
+	return m_InputPacketCount;
+}
+
+ULONGLONG CTsDescrambler::GetScramblePacketCount(void) const
+{
+	// 復号漏れパケット数を返す
+	return m_ScramblePacketCount;
+}
+
+void CTsDescrambler::ResetScramblePacketCount(void)
+{
+	m_ScramblePacketCount = 0;
+}
+
+int CTsDescrambler::GetServiceIndexByID(WORD ServiceID) const
+{
+	int Index;
+
+	// プログラムIDからサービスインデックスを検索する
+	for (Index = (int)m_ServiceList.size() - 1 ; Index >= 0 ; Index--) {
+		if (m_ServiceList[Index].ServiceID == ServiceID)
+			break;
+	}
+
+	return Index;
+}
+
+bool CTsDescrambler::SetTargetServiceID(WORD ServiceID)
+{
+	if (m_DescrambleServiceID != ServiceID) {
+		TRACE(TEXT("CTsDescrambler::SetTargetServiceID() SID = %d (%04x)\n"),
+			  ServiceID, ServiceID);
+
+		CBlockLock Lock(&m_DecoderLock);
+
+		m_DescrambleServiceID = ServiceID;
+
+		for (size_t i = 0 ; i < m_ServiceList.size() ; i++) {
+			CDescramblePmtTable *pPmtTable = dynamic_cast<CDescramblePmtTable *>(m_PidMapManager.GetMapTarget(m_ServiceList[i].PmtPID));
+
+			if (pPmtTable) {
+				const bool bTarget = m_DescrambleServiceID == 0
+						|| m_ServiceList[i].ServiceID == m_DescrambleServiceID;
+
+				if (bTarget && !m_ServiceList[i].bTarget) {
+					pPmtTable->SetTarget();
+					m_ServiceList[i].bTarget = true;
+				}
+			}
+		}
+
+		for (size_t i = 0 ; i < m_ServiceList.size() ; i++) {
+			CDescramblePmtTable *pPmtTable = dynamic_cast<CDescramblePmtTable *>(m_PidMapManager.GetMapTarget(m_ServiceList[i].PmtPID));
+
+			if (pPmtTable) {
+				const bool bTarget = m_DescrambleServiceID == 0
+						|| m_ServiceList[i].ServiceID == m_DescrambleServiceID;
+
+				if (!bTarget && m_ServiceList[i].bTarget) {
+					pPmtTable->ResetTarget();
+					m_ServiceList[i].bTarget = false;
+				}
+			}
+		}
+
+#ifdef _DEBUG
+		PrintStatus();
+#endif
+	}
+	return true;
+}
+
+WORD CTsDescrambler::GetTargetServiceID() const
+{
+	return m_DescrambleServiceID;
+}
+
+WORD CTsDescrambler::GetEcmPIDByServiceID(const WORD ServiceID) const
+{
+	CBlockLock Lock(&m_DecoderLock);
+
+	int Index = GetServiceIndexByID(ServiceID);
+	if (Index < 0)
+		return 0xFFFF;
+	return m_ServiceList[Index].EcmPID;
+}
+
+bool CTsDescrambler::SendCasCommand(const BYTE *pSendData, DWORD SendSize, BYTE *pRecvData, DWORD *pRecvSize)
+{
+	if (pSendData == NULL || SendSize == 0 || SendSize > 256
+			|| pRecvData == NULL || pRecvSize == NULL)
+		return false;
+
+	if (!m_CasCard.IsCardOpen())
+		return false;
+
+	CLocalEvent Event;
+	bool bSuccess = false;
+	Event.Create();
+	CCasSendCommandAccess *pAccess = new CCasSendCommandAccess(pSendData, SendSize, pRecvData, pRecvSize, &Event, &bSuccess);
+	if (!m_Queue.Enqueue(pAccess)) {
+		delete pAccess;
+		return false;
+	}
+	Event.Wait();
+	return bSuccess;
+}
+
+CTsDescrambler::ContractStatus CTsDescrambler::CheckContractStatus(const ServiceContractInfo &Info, WORD Date)
+{
+	CLocalEvent Event;
+	bool bSuccess = false;
+	Event.Create();
+	CConfirmContractAccess *pAccess =
+		new CConfirmContractAccess(&Info.VerificationInfo[0], (BYTE)Info.VerificationInfo.size(), Date, &Event, &bSuccess);
+	if (!m_Queue.Enqueue(pAccess)) {
+		delete pAccess;
+		return CONTRACT_ERROR;
+	}
+	Event.Wait();
+
+	return bSuccess ? CONTRACT_CONTRACTED : CONTRACT_UNCONTRACTED;
+}
+
+CTsDescrambler::ContractStatus CTsDescrambler::GetContractStatus(WORD NetworkID, WORD ServiceID, const SYSTEMTIME *pTime)
+{
+	if (!m_CasCard.IsCardOpen())
+		return CONTRACT_UNKNOWN;
+
+	ServiceContractInfo ContractInfo;
+
+	{
+		CBlockLock Lock(&m_DecoderLock);
+
+		ServiceContractMap::iterator itr =
+			m_ServiceContractList.find(GetServiceContractMapKey(NetworkID, ServiceID));
+		if (itr == m_ServiceContractList.end())
+			return CONTRACT_UNKNOWN;
+		ContractInfo = itr->second;
+	}
+
+	SYSTEMTIME st;
+	if (pTime != NULL)
+		st = *pTime;
+	else
+		::GetLocalTime(&st);
+	WORD Date;
+	CAribTime::SystemTimeToMjd(&st, &Date);
+
+#ifdef _DEBUG
+	WORD Year, Month, Day;
+	CAribTime::SplitAribMjd(Date, &Year, &Month, &Day);
+	TRACE(TEXT("Confirm contract : NID %04x / SID %04x / Date %04x(%d/%d/%d)\n"),
+		  NetworkID, ServiceID, Date, Year, Month, Day);
+#endif
+
+	return CheckContractStatus(ContractInfo, Date);
+}
+
+CTsDescrambler::ContractStatus CTsDescrambler::GetContractPeriod(WORD NetworkID, WORD ServiceID, SYSTEMTIME *pTime)
+{
+	if (!m_CasCard.IsCardOpen())
+		return CONTRACT_UNKNOWN;
+
+	ServiceContractInfo ContractInfo;
+
+	{
+		CBlockLock Lock(&m_DecoderLock);
+
+		ServiceContractMap::iterator itr =
+			m_ServiceContractList.find(GetServiceContractMapKey(NetworkID, ServiceID));
+		if (itr == m_ServiceContractList.end())
+			return CONTRACT_UNKNOWN;
+		ContractInfo = itr->second;
+	}
+
+	WORD Min, Max;
+	ContractStatus Stat;
+
+	Min = 51604;
+	Max = 65535;
+
+	Stat = CheckContractStatus(ContractInfo, Min);
+	if (Stat != CONTRACT_CONTRACTED)
+		return Stat;
+
+	Stat = CheckContractStatus(ContractInfo, Max);
+	if (Stat == CONTRACT_CONTRACTED) {
+		Min = Max;
+	} else if (Stat == CONTRACT_UNCONTRACTED) {
+		do {
+			WORD Cur = ((Max - Min) / 2) + Min;
+			Stat = CheckContractStatus(ContractInfo, Cur);
+			if (Stat == CONTRACT_CONTRACTED)
+				Min = Cur;
+			else if (Stat == CONTRACT_UNCONTRACTED)
+				Max = Cur;
+			else
+				return Stat;
+		} while (Max - Min > 1);
+	} else {
+		return Stat;
+	}
+
+	CAribTime::MjdToSystemTime(Min, pTime);
+
+	return CONTRACT_CONTRACTED;
+}
+
+bool CTsDescrambler::HasContractInfo(WORD NetworkID, WORD ServiceID) const
+{
+	CBlockLock Lock(&m_DecoderLock);
+
+	return m_ServiceContractList.find(GetServiceContractMapKey(NetworkID, ServiceID)) != m_ServiceContractList.end();
+}
+
+bool CTsDescrambler::SetInstruction(InstructionType Type)
+{
+	TRACE(TEXT("CTsDescrambler::SetInstruction(%d)\n"), Type);
+
+	switch (Type) {
+	case INSTRUCTION_NORMAL:
+		break;
+	case INSTRUCTION_SSE2:
+		if (!IsSSE2Available())
+			return false;
+		break;
+	case INSTRUCTION_SSSE3:
+		if (!IsSSSE3Available())
+			return false;
+		break;
+	default:
+		return false;
+	}
+
+	m_Instruction = Type;
+
+	return true;
+}
+
+CTsDescrambler::InstructionType CTsDescrambler::GetInstruction() const
+{
+	return m_Instruction;
+}
+
+bool CTsDescrambler::IsSSE2Available()
+{
+#ifdef MULTI2_SSE2
+	return CMulti2Decoder::IsSSE2Available();
+#else
+	return false;
+#endif
+}
+
+bool CTsDescrambler::IsSSSE3Available()
+{
+#ifdef MULTI2_SSSE3
+	return CMulti2Decoder::IsSSSE3Available();
+#else
+	return false;
+#endif
+}
+
+void CALLBACK CTsDescrambler::OnPatUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam)
+{
+	// PATが更新された
+	CTsDescrambler *pThis = static_cast<CTsDescrambler *>(pParam);
+	CPatTable *pPatTable = static_cast<CPatTable *>(pMapTarget);
+
+	TRACE(TEXT("CTsDescrambler::OnPatUpdated()\n"));
+
+	const WORD TsID = pPatTable->GetTransportStreamID();
+	if (TsID != pThis->m_CurTransportStreamID) {
+		// TSIDが変化したらリセットする
+		pThis->m_Queue.Clear();
+		for (WORD PID = 0x0002 ; PID < 0x2000 ; PID++) {
+			if (PID != PID_TOT && PID != PID_SDT)
+				pThis->m_PidMapManager.UnmapTarget(PID);
+		}
+
+		CCatTable *pCatTable = dynamic_cast<CCatTable*>(pThis->m_PidMapManager.GetMapTarget(PID_CAT));
+		if (pCatTable != NULL)
+			pCatTable->Reset();
+
+		CTotTable *pTotTable = dynamic_cast<CTotTable*>(pThis->m_PidMapManager.GetMapTarget(PID_TOT));
+		if (pTotTable != NULL)
+			pTotTable->Reset();
+
+		CSdtTable *pSdtTable = dynamic_cast<CSdtTable*>(pThis->m_PidMapManager.GetMapTarget(PID_SDT));
+		if (pSdtTable != NULL)
+			pSdtTable->Reset();
+
+		pThis->m_ServiceList.clear();
+		pThis->m_CurTransportStreamID = TsID;
+		pThis->m_EmmPID = 0xFFFF;
+	} else {
+		// 無くなったPMTをスクランブル解除対象から除外する
+		for (size_t i = 0 ; i < pThis->m_ServiceList.size() ; i++) {
+			const WORD PmtPID = pThis->m_ServiceList[i].PmtPID;
+			WORD j;
+
+			for (j = 0 ; j < pPatTable->GetProgramNum() ; j++) {
+				if (pPatTable->GetPmtPID(j) == PmtPID)
+					break;
+			}
+			if (j == pPatTable->GetProgramNum()) {
+				pThis->m_PidMapManager.UnmapTarget(PmtPID);
+				pThis->m_ServiceList[i].bTarget = false;
+			}
+		}
+	}
+
+	std::vector<TAG_SERVICEINFO> ServiceList;
+	ServiceList.resize(pPatTable->GetProgramNum());
+	for (WORD i = 0 ; i < pPatTable->GetProgramNum() ; i++) {
+		const WORD PmtPID = pPatTable->GetPmtPID(i);
+		const WORD ServiceID = pPatTable->GetProgramID(i);
+
+		ServiceList[i].bTarget = pThis->m_DescrambleServiceID == 0
+								|| ServiceID == pThis->m_DescrambleServiceID;
+		ServiceList[i].ServiceID = ServiceID;
+		ServiceList[i].PmtPID = PmtPID;
+		size_t j;
+		for (j = 0 ; j < pThis->m_ServiceList.size() ; j++) {
+			if (pThis->m_ServiceList[j].PmtPID == PmtPID)
+				break;
+		}
+		if (j < pThis->m_ServiceList.size()) {
+			ServiceList[i].EcmPID = pThis->m_ServiceList[j].EcmPID;
+			ServiceList[i].EsPIDList = pThis->m_ServiceList[j].EsPIDList;
+		} else {
+			ServiceList[i].EcmPID = 0xFFFF;
+			ServiceList[i].EsPIDList.clear();
+		}
+
+		CDescramblePmtTable *pPmtTable = dynamic_cast<CDescramblePmtTable *>(pThis->m_PidMapManager.GetMapTarget(PmtPID));
+		if (pPmtTable == NULL)
+			pThis->m_PidMapManager.MapTarget(PmtPID, new CDescramblePmtTable(pThis), OnPmtUpdated, pThis);
+	}
+	pThis->m_ServiceList = ServiceList;
+}
+
+void CALLBACK CTsDescrambler::OnPmtUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam)
+{
+	// PMTが更新された
+	CTsDescrambler *pThis = static_cast<CTsDescrambler *>(pParam);
+	CDescramblePmtTable *pPmtTable = static_cast<CDescramblePmtTable *>(pMapTarget);
+
+	const WORD ServiceID = pPmtTable->GetProgramNumberID();
+	const int ServiceIndex = pThis->GetServiceIndexByID(ServiceID);
+	if (ServiceIndex < 0)
+		return;
+
+	TRACE(TEXT("CTsDescrambler::OnPmtUpdated() SID = %04d\n"), ServiceID);
+
+	WORD CASystemID, EcmPID;
+	if (pThis->m_CasCard.GetCASystemID(&CASystemID)) {
+		EcmPID = pPmtTable->GetEcmPID(CASystemID);
+	} else {
+		EcmPID = 0xFFFF;
+	}
+	pThis->m_ServiceList[ServiceIndex].EcmPID = EcmPID;
+
+	pThis->m_ServiceList[ServiceIndex].EsPIDList.resize(pPmtTable->GetEsInfoNum());
+	for (WORD i = 0 ; i < pPmtTable->GetEsInfoNum() ; i++)
+		pThis->m_ServiceList[ServiceIndex].EsPIDList[i] = pPmtTable->GetEsPID(i);
+
+	pThis->m_ServiceList[ServiceIndex].bTarget = pThis->m_DescrambleServiceID == 0
+								|| ServiceID == pThis->m_DescrambleServiceID;
+	if (pThis->m_ServiceList[ServiceIndex].bTarget)
+		pPmtTable->SetTarget();
+	else
+		pPmtTable->ResetTarget();
+
+#ifdef _DEBUG
+	pThis->PrintStatus();
+#endif
+}
+
+void CALLBACK CTsDescrambler::OnCatUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam)
+{
+	// CATが更新された
+	CTsDescrambler *pThis = static_cast<CTsDescrambler *>(pParam);
+	CCatTable *pCatTable = static_cast<CCatTable *>(pMapTarget);
+
+	// EMMのPID追加
+	WORD SystemID, EmmPID;
+	if (pThis->m_CasCard.GetCASystemID(&SystemID)) {
+		EmmPID = pCatTable->GetEmmPID(SystemID);
+		if (EmmPID >= 0x1FFF || EmmPID == 0)
+			EmmPID = 0xFFFF;
+	} else {
+		EmmPID = 0xFFFF;
+	}
+	if (pThis->m_EmmPID != EmmPID) {
+		if (pThis->m_EmmPID < 0x1FFF)
+			pThis->m_PidMapManager.UnmapTarget(pThis->m_EmmPID);
+		if (EmmPID < 0x1FFF)
+			pThis->m_PidMapManager.MapTarget(EmmPID, new CEmmProcessor(pThis));
+		pThis->m_EmmPID = EmmPID;
+	}
+}
+
+void CALLBACK CTsDescrambler::OnSdtUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam)
+{
+	// SDTが更新された
+	CTsDescrambler *pThis = static_cast<CTsDescrambler *>(pParam);
+	CSdtTable *pSdtTable = static_cast<CSdtTable *>(pMapTarget);
+
+	const WORD NetworkID = pSdtTable->GetNetworkID();
+
+	// 契約確認情報を取得する
+	// TODO: CA_contract_info_descriptorが複数ある場合の対応
+	/*WORD CASystemID;
+	if (pThis->m_CasCard.GetCASystemID(&CASystemID))*/ {
+		TRACE(TEXT("Verification info : NID %04x\n"), NetworkID);
+		for (WORD i = 0; i < pSdtTable->GetServiceNum(); i++) {
+			const CDescBlock *pDescBlock = pSdtTable->GetItemDesc(i);
+			if (pDescBlock != NULL) {
+				for (WORD j = 0; j < pDescBlock->GetDescNum(); j++) {
+					const CBaseDesc *pDesc = pDescBlock->GetDescByIndex(j);
+					if (pDesc->GetTag() == CCaContractInfoDesc::DESC_TAG) {
+						const CCaContractInfoDesc *pCaContractInfoDesc = dynamic_cast<const CCaContractInfoDesc *>(pDesc);
+						if (pCaContractInfoDesc != NULL
+								//&& pCaContractInfoDesc->GetCaSystemID() == CASystemID
+								&& pCaContractInfoDesc->GetCaUnitID() != 0x0) {
+							const WORD ServiceID = pSdtTable->GetServiceID(i);
+							const DWORD MapKey = GetServiceContractMapKey(NetworkID, ServiceID);
+							ServiceContractMap::iterator itr = pThis->m_ServiceContractList.find(MapKey);
+							if (itr == pThis->m_ServiceContractList.end())
+								itr = pThis->m_ServiceContractList.insert(std::pair<DWORD, ServiceContractInfo>(MapKey, ServiceContractInfo())).first;
+							const BYTE VerificationInfoLength = pCaContractInfoDesc->GetContractVerificationInfoLength();
+							itr->second.VerificationInfo.resize(VerificationInfoLength);
+							if (VerificationInfoLength > 0)
+								pCaContractInfoDesc->GetContractVerificationInfo(
+									&itr->second.VerificationInfo[0], VerificationInfoLength);
+#ifdef _DEBUG
+							TCHAR szText[256];
+							int Length;
+							Length = ::wsprintf(szText, TEXT("  SID %04x : "), ServiceID);
+							for (BYTE k = 0; k < VerificationInfoLength; k++)
+								Length += ::wsprintf(&szText[Length], TEXT("%02x "), itr->second.VerificationInfo[k]);
+							::lstrcpy(&szText[Length], TEXT("\n"));
+							TRACE(szText);
+#endif
+							break;
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+#ifdef _DEBUG
+void CTsDescrambler::PrintStatus(void) const
+{
+	TRACE(TEXT("****** Descramble ES PIDs ******\n"));
+	for (WORD PID = 0x0001 ; PID < 0x2000 ; PID++) {
+		CEsProcessor *pEsProcessor = dynamic_cast<CEsProcessor*>(m_PidMapManager.GetMapTarget(PID));
+
+		if (pEsProcessor)
+			TRACE(TEXT("ES PID = %04x (%d)\n"), PID, PID);
+	}
+	TRACE(TEXT("****** Descramble ECM PIDs ******\n"));
+	for (WORD PID = 0x0001 ; PID < 0x2000 ; PID++) {
+		CEcmProcessor *pEcmProcessor = dynamic_cast<CEcmProcessor*>(m_PidMapManager.GetMapTarget(PID));
+
+		if (pEcmProcessor)
+			TRACE(TEXT("ECM PID = %04x (%d)\n"), PID, PID);
+	}
+	if (m_EmmPID < 0x1FFF)
+		TRACE(TEXT("EMM PID = %04x (%d)\n"), m_EmmPID, m_EmmPID);
+}
+#endif
+
+
+CDescramblePmtTable::CDescramblePmtTable(CTsDescrambler *pDescrambler)
+	: m_pDescrambler(pDescrambler)
+	, m_pMapManager(&pDescrambler->m_PidMapManager)
+	, m_pEcmProcessor(NULL)
+	, m_EcmPID(0xFFFF)
+	, m_ServiceID(0)
+{
+}
+
+void CDescramblePmtTable::UnmapEcmTarget()
+{
+	// ECMが他のスクランブル解除対象サービスと異なる場合はアンマップ
+	if (m_EcmPID < 0x1FFF) {
+		bool bFound = false;
+		for (size_t i = 0 ; i < m_pDescrambler->m_ServiceList.size() ; i++) {
+			if (m_pDescrambler->m_ServiceList[i].ServiceID != m_ServiceID
+					&& m_pDescrambler->m_ServiceList[i].bTarget
+					&& m_pDescrambler->m_ServiceList[i].EcmPID == m_EcmPID) {
+				bFound = true;
+				break;
+			}
+		}
+		if (!bFound)
+			m_pMapManager->UnmapTarget(m_EcmPID);
+	}
+
+	UnmapEsTarget();
+}
+
+void CDescramblePmtTable::UnmapEsTarget()
+{
+	// ESのPIDマップ削除
+	for (size_t i = 0 ; i < m_EsPIDList.size() ; i++) {
+		const WORD EsPID = m_EsPIDList[i];
+		bool bFound = false;
+
+		for (size_t j = 0 ; j < m_pDescrambler->m_ServiceList.size() ; j++) {
+			if (m_pDescrambler->m_ServiceList[j].ServiceID != m_ServiceID
+					&& m_pDescrambler->m_ServiceList[j].bTarget) {
+				for (size_t k = 0 ; k < m_pDescrambler->m_ServiceList[j].EsPIDList.size() ; k++) {
+					if (m_pDescrambler->m_ServiceList[j].EsPIDList[k] == EsPID) {
+						bFound = true;
+						break;
+					}
+				}
+				if (bFound)
+					break;
+			}
+		}
+		if (!bFound)
+			m_pMapManager->UnmapTarget(EsPID);
+	}
+}
+
+void CDescramblePmtTable::SetTarget()
+{
+	// スクランブル解除対象に設定
+
+	WORD CASystemID, EcmPID;
+	if (m_pDescrambler->m_CasCard.GetCASystemID(&CASystemID)) {
+		EcmPID = GetEcmPID(CASystemID);
+		if (EcmPID >= 0x1FFF)
+			EcmPID = 0xFFFF;
+	} else {
+		EcmPID = 0xFFFF;
+	}
+
+	if (EcmPID < 0x1FFF) {
+		if (m_EcmPID < 0x1FFF) {
+			// ECMとESのPIDをアンマップ
+			if (EcmPID != m_EcmPID) {
+				UnmapEcmTarget();
+			} else {
+				UnmapEsTarget();
+			}
+		}
+
+		m_pEcmProcessor = dynamic_cast<CEcmProcessor*>(m_pMapManager->GetMapTarget(EcmPID));
+		if (m_pEcmProcessor == NULL) {
+			// ECM処理内部クラス新規マップ
+			m_pEcmProcessor = new CEcmProcessor(m_pDescrambler);
+			m_pMapManager->MapTarget(EcmPID, m_pEcmProcessor);
+		}
+		m_EcmPID = EcmPID;
+
+		// ESのPIDマップ追加
+		m_EsPIDList.resize(GetEsInfoNum());
+		for (WORD i = 0 ; i < GetEsInfoNum() ; i++) {
+			const WORD EsPID = GetEsPID(i);
+			const CTsDescrambler::CEsProcessor *pEsProcessor = dynamic_cast<CTsDescrambler::CEsProcessor*>(m_pMapManager->GetMapTarget(EsPID));
+
+			if (pEsProcessor == NULL
+					|| pEsProcessor->GetEcmProcessor() != m_pEcmProcessor)
+				m_pMapManager->MapTarget(EsPID, new CTsDescrambler::CEsProcessor(m_pEcmProcessor));
+			m_EsPIDList[i] = EsPID;
+		}
+	} else {
+		ResetTarget();
+	}
+
+	m_ServiceID = GetProgramNumberID();
+}
+
+void CDescramblePmtTable::ResetTarget()
+{
+	// スクランブル解除対象から除外
+	if (m_EcmPID < 0x1FFF) {
+		// ECMとESのPIDをアンマップ
+		UnmapEcmTarget();
+
+		m_pEcmProcessor = NULL;
+		m_EcmPID = 0xFFFF;
+		m_EsPIDList.clear();
+	}
+}
+
+void CDescramblePmtTable::OnPidUnmapped(const WORD wPID)
+{
+	ResetTarget();
+
+	CPmtTable::OnPidUnmapped(wPID);
+}
+
+
+//////////////////////////////////////////////////////////////////////
+// CEcmProcessor 構築/消滅
+//////////////////////////////////////////////////////////////////////
+
+DWORD CEcmProcessor::m_EcmErrorCount = 0;
+bool CEcmProcessor::m_bCardReaderHung = false;
+
+CEcmProcessor::CEcmProcessor(CTsDescrambler *pDescrambler)
+	: CPsiSingleTable(true)
+	, m_pDescrambler(pDescrambler)
+#ifdef MULTI2_SIMD
+	, m_Multi2Decoder(
+#ifdef MULTI2_SSE2
+		pDescrambler->m_Instruction == CTsDescrambler::INSTRUCTION_SSE2 ? CMulti2Decoder::INSTRUCTION_SSE2 :
+#endif
+#ifdef MULTI2_SSSE3
+		pDescrambler->m_Instruction == CTsDescrambler::INSTRUCTION_SSSE3 ? CMulti2Decoder::INSTRUCTION_SSSE3 :
+#endif
+		CMulti2Decoder::INSTRUCTION_NORMAL
+		)
+#endif
+	, m_EcmPID(0xFFFF)
+	, m_bEcmReceived(false)
+	, m_bLastEcmSucceed(true)
+	, m_bOddKeyValid(false)
+	, m_bEvenKeyValid(false)
+	, m_LastChangedKey(0)
+	, m_bEcmErrorSent(false)
+	, m_LastScramblingCtrl(0)
+{
+	// MULTI2デコーダにシステムキーと初期CBCをセット
+	if (m_pDescrambler->m_CasCard.IsCardOpen())
+		m_Multi2Decoder.Initialize(m_pDescrambler->m_CasCard.GetSystemKey(),
+								   m_pDescrambler->m_CasCard.GetInitialCbc());
+
+	m_EcmProcessEvent.Create(true, true);
+
+	::ZeroMemory(m_LastKsData, sizeof(m_LastKsData));
+}
+
+void CEcmProcessor::OnPidMapped(const WORD wPID, const PVOID pParam)
+{
+	TRACE(TEXT("CEcmProcessor::OnPidMapped() PID = %d (0x%04x)\n"), wPID, wPID);
+	m_EcmPID = wPID;
+	AddRef();
+}
+
+void CEcmProcessor::OnPidUnmapped(const WORD wPID)
+{
+	TRACE(TEXT("CEcmProcessor::OnPidUnmapped() PID = %d (0x%04x)\n"), wPID, wPID);
+
+	//CPsiSingleTable::OnPidUnmapped(wPID);
+	ReleaseRef();
+}
+
+const bool CEcmProcessor::DescramblePacket(CTsPacket *pTsPacket)
+{
+	const BYTE ScramblingCtrl = pTsPacket->m_Header.byTransportScramblingCtrl;
+	if (!(ScramblingCtrl & 2))
+		return true;
+
+	if (!m_bEcmReceived) {
+		// まだECMが来ていない
+		m_pDescrambler->m_ScramblePacketCount++;
+		return false;
+	}
+
+	const bool bEven = !(ScramblingCtrl & 1);
+
+	m_Multi2Lock.Lock();
+
+	if (m_LastScramblingCtrl != ScramblingCtrl) {
+		if (m_LastScramblingCtrl != 0) {
+			/*
+				一つのECMで複数のストリームが対象になっている時、
+				ストリームによってOdd/Evenの切り替わるタイミングが違う事がある?
+				(未確認だが、不具合報告からの推測)
+				無効にするのをECMのKsが変わったタイミングにしておく
+			*/
+#if 0
+			// Odd/Evenが切り替わった時にもう片方を無効にする(古いキーが使われ続けるのを防ぐため)
+			if (bEven)
+				m_bOddKeyValid = false;
+			else
+				m_bEvenKeyValid = false;
+#endif
+
+			// ECM処理中であれば待ってみる
+			if (((bEven && !m_bEvenKeyValid) || (!bEven && !m_bOddKeyValid))
+					&& !m_EcmProcessEvent.IsSignaled()
+					&& !m_bCardReaderHung) {
+				m_Multi2Lock.Unlock();
+				m_EcmProcessEvent.Wait(1000);
+				m_Multi2Lock.Lock();
+			}
+		} else {
+			// 最初のECM処理中であれば終わるまで待つ
+			m_Multi2Lock.Unlock();
+			m_EcmProcessEvent.Wait(3000);
+			m_Multi2Lock.Lock();
+		}
+
+		m_LastScramblingCtrl = ScramblingCtrl;
+	}
+
+	// スクランブル解除
+	if ((bEven && m_bEvenKeyValid) || (!bEven && m_bOddKeyValid)) {
+		if (m_Multi2Decoder.Decode
+				(pTsPacket->GetPayloadData(),
+				(DWORD)pTsPacket->GetPayloadSize(),
+				ScramblingCtrl)) {
+			m_Multi2Lock.Unlock();
+
+			// トランスポートスクランブル制御再設定
+			pTsPacket->SetAt(3UL, pTsPacket->GetAt(3UL) & 0x3FU);
+			pTsPacket->m_Header.byTransportScramblingCtrl = 0;
+			return true;
+		}
+	}
+
+	m_Multi2Lock.Unlock();
+
+	m_pDescrambler->m_ScramblePacketCount++;
+
+	return false;
+}
+
+// Ksの比較
+static inline bool CompareKs(const void *pKey1, const void *pKey2)
+{
+#ifdef _WIN64
+	return *static_cast<const ULONGLONG*>(pKey1) == *static_cast<const ULONGLONG*>(pKey2);
+#else
+	return static_cast<const DWORD*>(pKey1)[0] == static_cast<const DWORD*>(pKey2)[0]
+		&& static_cast<const DWORD*>(pKey1)[1] == static_cast<const DWORD*>(pKey2)[1];
+#endif
+}
+
+const bool CEcmProcessor::OnTableUpdate(const CPsiSection *pCurSection, const CPsiSection *pOldSection)
+{
+	if (pCurSection->GetTableID() != 0x82)
+		return false;
+
+	const WORD PayloadSize = pCurSection->GetPayloadSize();
+
+	if (PayloadSize < MIN_ECM_DATA_SIZE || PayloadSize > MAX_ECM_DATA_SIZE)
+		return false;
+
+	// ECMが変わったらキー取得が成功するまで無効にする
+	m_Multi2Lock.Lock();
+	if (m_LastChangedKey == 1) {
+		m_bEvenKeyValid = false;
+	} else if (m_LastChangedKey == 2) {
+		m_bOddKeyValid = false;
+	}
+	m_Multi2Lock.Unlock();
+
+	// 前のECM処理が終わるまで待つ
+	if (!m_EcmProcessEvent.IsSignaled()) {
+		if (m_bCardReaderHung)
+			return false;
+		if (m_EcmProcessEvent.Wait(3000) == WAIT_TIMEOUT) {
+			OnCardReaderHung();
+			return false;
+		}
+	}
+
+	// CASアクセスキューに追加
+	m_EcmProcessEvent.Reset();
+	CEcmAccess *pEcmAccess = new CEcmAccess(this, pCurSection->GetPayloadData(), PayloadSize, &m_EcmProcessEvent);
+	if (m_pDescrambler->m_Queue.Enqueue(pEcmAccess)) {
+		m_bEcmReceived = true;
+	} else {
+		delete pEcmAccess;
+	}
+
+	return true;
+}
+
+const bool CEcmProcessor::SetScrambleKey(CCasCard *pCasCard, const BYTE *pEcmData, DWORD EcmSize)
+{
+	// ECMをCASカードに渡してキー取得
+	const BYTE *pKsData = pCasCard->GetKsFromEcm(pEcmData, EcmSize);
+
+	if (!pKsData) {
+		int ErrorCode = pCasCard->GetLastErrorCode();
+		// ECM処理失敗時は一度だけ再送信する
+		if (m_bLastEcmSucceed
+				&& ErrorCode != CCasCard::ERR_CARDNOTOPEN
+				&& ErrorCode != CCasCard::ERR_ECMREFUSED
+				&& ErrorCode != CCasCard::ERR_BADARGUMENT) {
+			// 再送信してみる
+			pKsData = pCasCard->GetKsFromEcm(pEcmData, EcmSize);
+			if (!pKsData) {
+				ErrorCode = pCasCard->GetLastErrorCode();
+				if (ErrorCode != CCasCard::ERR_ECMREFUSED) {
+					// カードを開き直して再初期化してみる
+					TRACE(TEXT("CEcmProcessor::SetScrambleKey() : エラーのためカード再初期化\n"));
+					if (pCasCard->ReOpenCard()) {
+						m_Multi2Decoder.Initialize(pCasCard->GetSystemKey(),
+												   pCasCard->GetInitialCbc());
+						pKsData = pCasCard->GetKsFromEcm(pEcmData, EcmSize);
+						if (!pKsData)
+							ErrorCode = pCasCard->GetLastErrorCode();
+					}
+				}
+			}
+		}
+
+		// 連続してエラーが起きたら通知
+		if (!pKsData && !m_bLastEcmSucceed
+				&& ErrorCode != CCasCard::ERR_CARDNOTOPEN) {
+			if (!m_bEcmErrorSent && m_EcmPID < 0x1FFF) {
+				CTsDescrambler::EcmErrorInfo Info;
+
+				Info.pszText = pCasCard->GetLastErrorText();
+				Info.EcmPID = m_EcmPID;
+				m_pDescrambler->SendDecoderEvent(
+					ErrorCode == CCasCard::ERR_ECMREFUSED ?
+						CTsDescrambler::EVENT_ECM_REFUSED : CTsDescrambler::EVENT_ECM_ERROR,
+					&Info);
+				m_bEcmErrorSent = true;
+			}
+		}
+	}
+
+	m_Multi2Lock.Lock();
+
+	// スクランブルキー更新
+	m_Multi2Decoder.SetScrambleKey(pKsData);
+
+	// ECM処理成功状態更新
+	const bool bSucceeded = pKsData != NULL;
+	m_LastChangedKey = 0;
+	if (bSucceeded) {
+		if (m_bLastEcmSucceed) {
+			// キーが変わったら有効状態更新
+			const bool bOddKeyChanged  = !CompareKs(&m_LastKsData[0], &pKsData[0]);
+			const bool bEvenKeyChanged = !CompareKs(&m_LastKsData[8], &pKsData[8]);
+			if (bOddKeyChanged)
+				m_bOddKeyValid = true;
+			if (bEvenKeyChanged)
+				m_bEvenKeyValid = true;
+			if (bOddKeyChanged) {
+				if (!bEvenKeyChanged)
+					m_LastChangedKey = 1;
+			} else if (bEvenKeyChanged) {
+				m_LastChangedKey = 2;
+			}
+		} else {
+			m_bOddKeyValid = true;
+			m_bEvenKeyValid = true;
+		}
+		::CopyMemory(m_LastKsData, pKsData, 16);
+	} else {
+		m_bOddKeyValid = false;
+		m_bEvenKeyValid = false;
+		m_EcmErrorCount++;
+	}
+	m_bLastEcmSucceed = bSucceeded;
+
+	m_Multi2Lock.Unlock();
+
+	return true;
+}
+
+void CEcmProcessor::OnCardReaderHung()
+{
+	if (!m_bCardReaderHung) {
+		m_bCardReaderHung = true;
+		m_pDescrambler->SendDecoderEvent(CTsDescrambler::EVENT_CARD_READER_HUNG);
+	}
+}
+
+
+//////////////////////////////////////////////////////////////////////
+// CEmmProcessor 構築/消滅
+//////////////////////////////////////////////////////////////////////
+
+CEmmProcessor::CEmmProcessor(CTsDescrambler *pDescrambler)
+	: CPsiStreamTable(NULL, true)
+	, m_pDescrambler(pDescrambler)
+{
+}
+
+void CEmmProcessor::OnPidMapped(const WORD wPID, const PVOID pParam)
+{
+	TRACE(TEXT("CEmmProcessor::OnPidMapped() PID = %d (0x%04x)\n"), wPID, wPID);
+	AddRef();
+}
+
+void CEmmProcessor::OnPidUnmapped(const WORD wPID)
+{
+	TRACE(TEXT("CEmmProcessor::OnPidUnmapped() PID = %d (0x%04x)\n"), wPID, wPID);
+
+	//CPsiSingleTable::OnPidUnmapped(wPID);
+	ReleaseRef();
+}
+
+const bool CEmmProcessor::OnTableUpdate(const CPsiSection *pCurSection)
+{
+	if (pCurSection->GetTableID() != 0x84)
+		return false;
+
+	const WORD DataSize = pCurSection->GetPayloadSize();
+	const BYTE *pHexData = pCurSection->GetPayloadData();
+
+	const BYTE *pCardID = m_pDescrambler->m_CasCard.GetCardID();
+	if (pCardID == NULL)
+		return true;
+
+	WORD Pos = 0;
+	while (DataSize >= Pos + 17) {
+		const WORD EmmSize = (WORD)pHexData[Pos + 6] + 7;
+		if (EmmSize < 17 || EmmSize > MAX_EMM_DATA_SIZE || DataSize < Pos + EmmSize)
+			break;
+
+		if (::memcmp(pCardID, &pHexData[Pos], 6) == 0) {
+			SYSTEMTIME st;
+			const CTotTable *pTotTable = dynamic_cast<const CTotTable*>(m_pDescrambler->m_PidMapManager.GetMapTarget(PID_TOT));
+			if (pTotTable == NULL || !pTotTable->GetDateTime(&st))
+				break;
+
+			FILETIME ft;
+			ULARGE_INTEGER TotTime, LocalTime;
+
+			::SystemTimeToFileTime(&st, &ft);
+			TotTime.LowPart = ft.dwLowDateTime;
+			TotTime.HighPart = ft.dwHighDateTime;
+			::GetLocalTime(&st);
+			::SystemTimeToFileTime(&st, &ft);
+			LocalTime.LowPart = ft.dwLowDateTime;
+			LocalTime.HighPart = ft.dwHighDateTime;
+			if (TotTime.QuadPart + (10000000ULL * 60ULL * 60ULL * EMM_PROCESS_TIME) > LocalTime.QuadPart) {
+				// CASアクセスキューに追加
+				CEmmAccess *pEmmAccess = new CEmmAccess(this, &pHexData[Pos], EmmSize);
+				if (!m_pDescrambler->m_Queue.Enqueue(pEmmAccess))
+					delete pEmmAccess;
+			}
+			break;
+		}
+
+		Pos += EmmSize;
+	}
+
+	return true;
+}
+
+const bool CEmmProcessor::ProcessEmm(CCasCard *pCasCard, const BYTE *pData, DWORD DataSize)
+{
+	if (pCasCard->SendEmmSection(pData, DataSize)) {
+		m_pDescrambler->SendDecoderEvent(CTsDescrambler::EVENT_EMM_PROCESSED, NULL);
+	} else {
+		CTsDescrambler::EmmErrorInfo Info;
+		Info.pszText = pCasCard->GetLastErrorText();
+		m_pDescrambler->SendDecoderEvent(CTsDescrambler::EVENT_EMM_ERROR, &Info);
+	}
+
+	return true;
+}
+
+
+//////////////////////////////////////////////////////////////////////
+// CTsDescrambler::CEsProcessor 構築/消滅
+//////////////////////////////////////////////////////////////////////
+
+CTsDescrambler::CEsProcessor::CEsProcessor(CEcmProcessor *pEcmProcessor)
+	: CTsPidMapTarget()
+	, m_pEcmProcessor(pEcmProcessor)
+{
+}
+
+CTsDescrambler::CEsProcessor::~CEsProcessor()
+{
+}
+
+const bool CTsDescrambler::CEsProcessor::StorePacket(const CTsPacket *pPacket)
+{
+	// スクランブル解除
+	if (pPacket->IsScrambled()
+			&& !m_pEcmProcessor->DescramblePacket(const_cast<CTsPacket *>(pPacket)))
+		return false;
+
+	return true;
+}
+
+void CTsDescrambler::CEsProcessor::OnPidMapped(const WORD wPID, const PVOID pParam)
+{
+	TRACE(TEXT("CEsProcessor::OnPidMapped() PID = %d (0x%04x)\n"), wPID, wPID);
+}
+
+void CTsDescrambler::CEsProcessor::OnPidUnmapped(const WORD wPID)
+{
+	TRACE(TEXT("CEsProcessor::OnPidUnmapped() PID = %d (0x%04x)\n"), wPID, wPID);
+	delete this;
+}
+
+
+CCasAccessQueue::CCasAccessQueue(CCasCard *pCasCard)
+	: m_pCasCard(pCasCard)
+	, m_hThread(NULL)
+	, m_bAvailable(false)
+	, m_bKillEvent(false)
+{
+}
+
+CCasAccessQueue::~CCasAccessQueue()
+{
+	EndCasThread();
+}
+
+void CCasAccessQueue::Clear()
+{
+	CBlockLock Lock(&m_Lock);
+
+	std::deque<CCasAccess*>::iterator itr;
+	for (itr = m_Queue.begin() ; itr != m_Queue.end() ; itr++)
+		delete *itr;
+	m_Queue.clear();
+}
+
+bool CCasAccessQueue::Enqueue(CCasAccess *pAccess)
+{
+	if (!m_bAvailable || pAccess == NULL)
+		return false;
+
+	CBlockLock Lock(&m_Lock);
+
+	m_Queue.push_back(pAccess);
+	m_Event.Set();
+	return true;
+}
+
+bool CCasAccessQueue::BeginCasThread(CCardReader::ReaderType ReaderType, LPCTSTR pszReaderName)
+{
+	if (m_hThread)
+		return false;
+	if (m_Event.IsCreated())
+		m_Event.Reset();
+	else
+		m_Event.Create();
+	m_ReaderType = ReaderType;
+	m_pszReaderName = pszReaderName;
+	m_bKillEvent = false;
+	m_bStartEvent = false;
+	m_hThread = (HANDLE)::_beginthreadex(NULL, 0, CasAccessThread, this, 0, NULL);
+	if (m_hThread == NULL)
+		return false;
+	if (m_Event.Wait(20000) == WAIT_TIMEOUT) {
+		::TerminateThread(m_hThread, -1);
+		::CloseHandle(m_hThread);
+		m_hThread = NULL;
+		SetError(TEXT("カードリーダーのオープンで、カードリーダーが応答しません。"));
+		return false;
+	}
+	if (!m_pCasCard->IsCardOpen()) {
+		::WaitForSingleObject(m_hThread, INFINITE);
+		::CloseHandle(m_hThread);
+		m_hThread = NULL;
+		return false;
+	}
+	m_bStartEvent = true;
+	m_bAvailable = true;
+	ClearError();
+	return true;
+}
+
+bool CCasAccessQueue::EndCasThread()
+{
+	if (m_hThread) {
+		m_bAvailable = false;
+		m_bKillEvent = true;
+		m_Event.Set();
+		if (::WaitForSingleObject(m_hThread, 5000) == WAIT_TIMEOUT) {
+			TRACE(TEXT("Terminate CasAccessThread\n"));
+			::TerminateThread(m_hThread, -1);
+		}
+		::CloseHandle(m_hThread);
+		m_hThread = NULL;
+	}
+	Clear();
+	return true;
+}
+
+unsigned int __stdcall CCasAccessQueue::CasAccessThread(LPVOID lpParameter)
+{
+	CCasAccessQueue *pThis=static_cast<CCasAccessQueue*>(lpParameter);
+
+	// カードリーダからCASカードを検索して開く
+	if (!pThis->m_pCasCard->OpenCard(pThis->m_ReaderType, pThis->m_pszReaderName)) {
+		pThis->SetError(pThis->m_pCasCard->GetLastErrorException());
+		pThis->m_Event.Set();
+		return 1;
+	}
+	pThis->m_Event.Set();
+	while (!pThis->m_bStartEvent)
+		::Sleep(0);
+
+	while (true) {
+		pThis->m_Event.Wait();
+		if (pThis->m_bKillEvent)
+			break;
+		while (true) {
+			pThis->m_Lock.Lock();
+			if (pThis->m_Queue.empty()) {
+				pThis->m_Lock.Unlock();
+				break;
+			}
+			CCasAccess *pCasAccess = pThis->m_Queue.front();
+			pThis->m_Queue.pop_front();
+			pThis->m_Lock.Unlock();
+			pCasAccess->Process(pThis->m_pCasCard);
+			delete pCasAccess;
+		}
+	}
+
+	// CASカードを閉じる
+	pThis->m_pCasCard->CloseCard();
+
+	TRACE(TEXT("End CasAccessThread\n"));
+
+	return 0;
+}
diff -ruN a/TSTask/BonTsEngine/TsDescrambler.h b/TSTask/BonTsEngine/TsDescrambler.h
--- a/TSTask/BonTsEngine/TsDescrambler.h	1970-01-01 09:00:00.000000000 +0900
+++ b/TSTask/BonTsEngine/TsDescrambler.h	2015-08-12 19:35:00.000000000 +0900
@@ -0,0 +1,188 @@
+// TsDescrambler.h: CTsDescrambler クラスのインターフェイス
+//
+//////////////////////////////////////////////////////////////////////
+
+#pragma once
+
+
+#include <deque>
+#include <vector>
+#include <map>
+#include "MediaDecoder.h"
+#include "TsStream.h"
+#include "TsTable.h"
+#include "TsUtilClass.h"
+#include "CasCard.h"
+
+
+class CEcmProcessor;
+class CEmmProcessor;
+
+class CCasAccess
+{
+public:
+	virtual ~CCasAccess() {}
+	virtual bool Process(CCasCard *pCasCard) = 0;
+};
+
+class CCasAccessQueue : public CBonBaseClass
+{
+	std::deque<CCasAccess*> m_Queue;
+	CCasCard *m_pCasCard;
+	CCardReader::ReaderType m_ReaderType;
+	LPCTSTR m_pszReaderName;
+	HANDLE m_hThread;
+	CLocalEvent m_Event;
+	volatile bool m_bAvailable;
+	volatile bool m_bKillEvent;
+	volatile bool m_bStartEvent;
+	CCriticalLock m_Lock;
+
+	static unsigned int __stdcall CasAccessThread(LPVOID lpParameter);
+
+public:
+	CCasAccessQueue(CCasCard *pCasCard);
+	~CCasAccessQueue();
+	void Clear();
+	bool Enqueue(CCasAccess *pAccess);
+	bool BeginCasThread(CCardReader::ReaderType ReaderType, LPCTSTR pszReaderName);
+	bool EndCasThread();
+};
+
+
+/////////////////////////////////////////////////////////////////////////////
+// MULTI2スクランブル解除(ECMによりペイロードのスクランブルを解除する)
+/////////////////////////////////////////////////////////////////////////////
+// Input	#0	: CTsPacket		暗号TSパケット
+// Output	#0	: CTsPacket		平分TSパケット
+/////////////////////////////////////////////////////////////////////////////
+
+class CTsDescrambler : public CMediaDecoder
+{
+public:
+	enum {
+		EVENT_EMM_PROCESSED		= 0x00000001UL,
+		EVENT_EMM_ERROR			= 0x00000002UL,
+		EVENT_ECM_ERROR			= 0x00000003UL,
+		EVENT_ECM_REFUSED		= 0x00000004UL,
+		EVENT_CARD_READER_HUNG	= 0x00000005UL
+	};
+
+	struct EcmErrorInfo {
+		LPCTSTR pszText;
+		WORD EcmPID;
+	};
+
+	struct EmmErrorInfo {
+		LPCTSTR pszText;
+	};
+
+	enum InstructionType {
+		INSTRUCTION_NORMAL,
+		INSTRUCTION_SSE2,
+		INSTRUCTION_SSSE3
+	};
+
+	enum ContractStatus {
+		CONTRACT_CONTRACTED,
+		CONTRACT_UNCONTRACTED,
+		CONTRACT_UNKNOWN,
+		CONTRACT_ERROR
+	};
+
+	CTsDescrambler(IEventHandler *pEventHandler = NULL);
+	virtual ~CTsDescrambler();
+
+// CMediaDecoder
+	virtual void Reset(void);
+	virtual const bool InputMedia(CMediaData *pMediaData, const DWORD dwInputIndex = 0UL);
+
+// CTsDescrambler
+	bool EnableDescramble(bool bDescramble);
+	bool IsDescrambleEnabled() const;
+	bool EnableEmmProcess(bool bEnable);
+	bool IsEmmProcessEnabled() const;
+
+	bool OpenCasCard(CCardReader::ReaderType ReaderType = CCardReader::READER_SCARD, LPCTSTR pszReaderName = NULL);
+	void CloseCasCard(void);
+	bool IsCasCardOpen() const;
+	CCardReader::ReaderType GetCardReaderType() const;
+	LPCTSTR GetCardReaderName() const;
+	bool GetCasCardInfo(CCasCard::CasCardInfo *pInfo) const;
+	bool GetCasCardID(BYTE *pCardID) const;
+	int FormatCasCardID(LPTSTR pszText,int MaxLength) const;
+	char GetCasCardManufacturerID() const;
+	BYTE GetCasCardVersion() const;
+
+	ULONGLONG GetInputPacketCount(void) const;
+	ULONGLONG GetScramblePacketCount(void) const;
+	void ResetScramblePacketCount(void);
+
+	bool SetTargetServiceID(WORD ServiceID = 0);
+	WORD GetTargetServiceID() const;
+	WORD GetEcmPIDByServiceID(const WORD ServiceID) const;
+	bool SendCasCommand(const BYTE *pSendData, DWORD SendSize, BYTE *pRecvData, DWORD *pRecvSize);
+
+	ContractStatus GetContractStatus(WORD NetworkID, WORD ServiceID, const SYSTEMTIME *pTime = NULL);
+	ContractStatus GetContractPeriod(WORD NetworkID, WORD ServiceID, SYSTEMTIME *pTime);
+	bool HasContractInfo(WORD NetworkID, WORD ServiceID) const;
+
+	bool SetInstruction(InstructionType Type);
+	InstructionType GetInstruction() const;
+	static bool IsSSE2Available();
+	static bool IsSSSE3Available();
+
+protected:
+	class CEsProcessor;
+
+	static void CALLBACK OnPatUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam);
+	static void CALLBACK OnPmtUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam);
+	static void CALLBACK OnCatUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam);
+	static void CALLBACK OnSdtUpdated(const WORD wPID, CTsPidMapTarget *pMapTarget, CTsPidMapManager *pMapManager, const PVOID pParam);
+
+	int GetServiceIndexByID(WORD ServiceID) const;
+
+#ifdef _DEBUG
+	void PrintStatus(void) const;
+#endif
+
+	bool m_bDescramble;
+	bool m_bProcessEmm;
+	CTsPidMapManager m_PidMapManager;
+	CCasCard m_CasCard;
+	CCasAccessQueue m_Queue;
+
+	WORD m_CurTransportStreamID;
+	WORD m_DescrambleServiceID;
+
+	struct TAG_SERVICEINFO {
+		bool bTarget;
+		WORD ServiceID;
+		WORD PmtPID;
+		WORD EcmPID;
+		std::vector<WORD> EsPIDList;
+	};
+	std::vector<TAG_SERVICEINFO> m_ServiceList;
+
+	struct ServiceContractInfo {
+		std::vector<BYTE> VerificationInfo;
+	};
+	typedef std::map<DWORD, ServiceContractInfo> ServiceContractMap;
+	static DWORD GetServiceContractMapKey(WORD NetworkID, WORD ServiceID)
+	{
+		return ((DWORD)NetworkID << 16) | (DWORD)ServiceID;
+	}
+	ServiceContractMap m_ServiceContractList;
+	ContractStatus CheckContractStatus(const ServiceContractInfo &Info, WORD Date);
+
+	ULONGLONG m_InputPacketCount;
+	ULONGLONG m_ScramblePacketCount;
+
+	InstructionType m_Instruction;
+
+	WORD m_EmmPID;
+
+	friend class CEcmProcessor;
+	friend class CEmmProcessor;
+	friend class CDescramblePmtTable;
+};
diff -ruN a/TSTask/BonTsEngine/TsStream.h b/TSTask/BonTsEngine/TsStream.h
--- a/TSTask/BonTsEngine/TsStream.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/BonTsEngine/TsStream.h	2015-08-12 19:35:00.000000000 +0900
@@ -13,6 +13,8 @@
 // TSパケット抽象化クラス
 /////////////////////////////////////////////////////////////////////////////
 
+#define TSPACKET_NEED_ALIGNED_PAYLOAD
+
 #define TS_PACKETSIZE	(188U)	// TSパケットサイズ
 
 class CTsPacket : public CMediaData
diff -ruN a/TSTask/Common/BasicMessage.h b/TSTask/Common/BasicMessage.h
--- a/TSTask/Common/BasicMessage.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/Common/BasicMessage.h	2015-08-12 19:35:00.000000000 +0900
@@ -40,6 +40,8 @@
 	TSTASK_DEFINE_MESSAGE(SetService);
 	TSTASK_DEFINE_MESSAGE(GetService);
 	TSTASK_DEFINE_MESSAGE(GetServiceList);
+	TSTASK_DEFINE_MESSAGE(OpenCasCard);
+	TSTASK_DEFINE_MESSAGE(CloseCasCard);
 	TSTASK_DEFINE_MESSAGE(GetStreamStatistics);
 	TSTASK_DEFINE_MESSAGE(ResetErrorStatistics);
 	TSTASK_DEFINE_MESSAGE(StartRecording);
@@ -66,6 +68,8 @@
 	TSTASK_DEFINE_MESSAGE_EVENT(TunerClosed);
 	TSTASK_DEFINE_MESSAGE_EVENT(ChannelChanged);
 	TSTASK_DEFINE_MESSAGE_EVENT(ServiceChanged);
+	TSTASK_DEFINE_MESSAGE_EVENT(CasCardOpened);
+	TSTASK_DEFINE_MESSAGE_EVENT(CasCardClosed);
 	TSTASK_DEFINE_MESSAGE_EVENT(RecordingStarted);
 	TSTASK_DEFINE_MESSAGE_EVENT(RecordingStopped);
 	TSTASK_DEFINE_MESSAGE_EVENT(RecordingFileChanged);
@@ -98,6 +102,7 @@
 	TSTASK_DEFINE_MESSAGE_PROPERTY(Value);
 	TSTASK_DEFINE_MESSAGE_PROPERTY(Status);
 	TSTASK_DEFINE_MESSAGE_PROPERTY(ServiceSelect);
+	TSTASK_DEFINE_MESSAGE_PROPERTY(Descramble);
 	TSTASK_DEFINE_MESSAGE_PROPERTY(Streams);
 	TSTASK_DEFINE_MESSAGE_PROPERTY(StartTime);
 	TSTASK_DEFINE_MESSAGE_PROPERTY(StartTickCount);
diff -ruN a/TSTask/Common/TSTaskBase.h b/TSTask/Common/TSTaskBase.h
--- a/TSTask/Common/TSTaskBase.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/Common/TSTaskBase.h	2015-08-12 19:35:00.000000000 +0900
@@ -100,6 +100,14 @@
 		SERVICE_SELECT_TRAILER
 	};
 
+	enum DescrambleType
+	{
+		DESCRAMBLE_NO,
+		DESCRAMBLE_ALL_SERVICES,
+		DESCRAMBLE_CURRENT_SERVICE,
+		DESCRAMBLE_TRAILER
+	};
+
 	enum
 	{
 		STREAM_MPEG1_VIDEO			= 0x00000001UL,
@@ -126,6 +134,7 @@
 		String FileName;
 		std::vector<String> Directories;
 		ServiceSelectType ServiceSelect;
+		DescrambleType Descramble;
 		DWORD Streams;
 	};
 
@@ -214,6 +223,15 @@
 	inline WORD GetVersionMinor(DWORD Version) { return (WORD)((Version >> 12) & 0xFFF); }
 	inline WORD GetVersionRevision(DWORD Version) { return (WORD)(Version & 0xFFF); }
 
+	enum Multi2InstructionType
+	{
+		MULTI2_INSTRUCTION_DEFAULT=-1,
+		MULTI2_INSTRUCTION_BASIC,
+		MULTI2_INSTRUCTION_SSE2,
+		MULTI2_INSTRUCTION_SSSE3,
+		MULTI2_INSTRUCTION_TRAILER
+	};
+
 }
 
 
diff -ruN a/TSTask/TSTask/ClientManager.cpp b/TSTask/TSTask/ClientManager.cpp
--- a/TSTask/TSTask/ClientManager.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/ClientManager.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -167,6 +167,22 @@
 		BroadcastMessage(Message);
 	}
 
+	void CClientManager::OnCasCardOpened(LPCWSTR pszReaderName)
+	{
+		CMessage Message(MESSAGE_EVENT_CasCardOpened);
+
+		Message.SetProperty(MESSAGE_PROPERTY_Name,pszReaderName);
+
+		BroadcastMessage(Message);
+	}
+
+	void CClientManager::OnCasCardClosed()
+	{
+		CMessage Message(MESSAGE_EVENT_CasCardClosed);
+
+		BroadcastMessage(Message);
+	}
+
 	void CClientManager::OnRecordingStarted(const RecordingInfo &Info)
 	{
 		CMessage Message(MESSAGE_EVENT_RecordingStarted);
@@ -177,6 +193,7 @@
 		Message.SetProperty(MESSAGE_PROPERTY_FileName,FileName);
 		Message.SetProperty(MESSAGE_PROPERTY_Directory,Directory);
 		Message.SetProperty(MESSAGE_PROPERTY_ServiceSelect,CMessageProperty::IntType(Info.Settings.ServiceSelect));
+		Message.SetProperty(MESSAGE_PROPERTY_Descramble,CMessageProperty::IntType(Info.Settings.Descramble));
 
 		BroadcastMessage(Message);
 	}
diff -ruN a/TSTask/TSTask/ClientManager.h b/TSTask/TSTask/ClientManager.h
--- a/TSTask/TSTask/ClientManager.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/ClientManager.h	2015-08-12 19:35:00.000000000 +0900
@@ -28,6 +28,8 @@
 		void OnTunerClosed() override;
 		void OnChannelChanged(DWORD Space,DWORD Channel,WORD ServiceID) override;
 		void OnServiceChanged(WORD ServiceID) override;
+		void OnCasCardOpened(LPCWSTR pszReaderName) override;
+		void OnCasCardClosed() override;
 		void OnRecordingStarted(const RecordingInfo &Info) override;
 		void OnRecordingStopped() override;
 		void OnRecordingFileChanged(LPCWSTR pszFileName) override;
diff -ruN a/TSTask/TSTask/CoreMessageHandler.cpp b/TSTask/TSTask/CoreMessageHandler.cpp
--- a/TSTask/TSTask/CoreMessageHandler.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/CoreMessageHandler.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -35,6 +35,8 @@
 			{MESSAGE_SetService,				&CCoreMessageHandler::OnSetService},
 			{MESSAGE_GetService,				&CCoreMessageHandler::OnGetService},
 			{MESSAGE_GetServiceList,			&CCoreMessageHandler::OnGetServiceList},
+			{MESSAGE_OpenCasCard,				&CCoreMessageHandler::OnOpenCasCard},
+			{MESSAGE_CloseCasCard,				&CCoreMessageHandler::OnCloseCasCard},
 			{MESSAGE_StartRecording,			&CCoreMessageHandler::OnStartRecording},
 			{MESSAGE_StopRecording,				&CCoreMessageHandler::OnStopRecording},
 			{MESSAGE_ChangeRecordingFile,		&CCoreMessageHandler::OnChangeRecordingFile},
@@ -290,6 +292,37 @@
 		return true;
 	}
 
+	bool CCoreMessageHandler::OnOpenCasCard(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse)
+	{
+		OutLog(LOG_INFO,L"カードオープンのメッセージを受信しました。");
+
+		String Name;
+		bool fHasName=pMessage->GetProperty(MESSAGE_PROPERTY_Name,&Name);
+
+		if (!m_Core.OpenCasCard(fHasName?Name.c_str():nullptr)) {
+			pResponse->SetProperty(MESSAGE_PROPERTY_Result,MESSAGE_RESULT_Failed);
+			return true;
+		}
+
+		pResponse->SetProperty(MESSAGE_PROPERTY_Result,MESSAGE_RESULT_OK);
+
+		return true;
+	}
+
+	bool CCoreMessageHandler::OnCloseCasCard(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse)
+	{
+		OutLog(LOG_INFO,L"カードクローズのメッセージを受信しました。");
+
+		if (!m_Core.CloseCasCard()) {
+			pResponse->SetProperty(MESSAGE_PROPERTY_Result,MESSAGE_RESULT_Failed);
+			return true;
+		}
+
+		pResponse->SetProperty(MESSAGE_PROPERTY_Result,MESSAGE_RESULT_OK);
+
+		return true;
+	}
+
 	bool CCoreMessageHandler::OnStartRecording(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse)
 	{
 		OutLog(LOG_INFO,L"録画開始のメッセージを受信しました。");
diff -ruN a/TSTask/TSTask/CoreMessageHandler.h b/TSTask/TSTask/CoreMessageHandler.h
--- a/TSTask/TSTask/CoreMessageHandler.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/CoreMessageHandler.h	2015-08-12 19:35:00.000000000 +0900
@@ -29,6 +29,8 @@
 		bool OnSetService(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
 		bool OnGetService(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
 		bool OnGetServiceList(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
+		bool OnOpenCasCard(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
+		bool OnCloseCasCard(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
 		bool OnStartRecording(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
 		bool OnStopRecording(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
 		bool OnChangeRecordingFile(CMessageServer *pServer,const CMessage *pMessage,CMessage *pResponse);
diff -ruN a/TSTask/TSTask/DtvEngine.cpp b/TSTask/TSTask/DtvEngine.cpp
--- a/TSTask/TSTask/DtvEngine.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/DtvEngine.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -27,6 +27,7 @@
 	, m_BonSrcDecoder(this)
 	, m_TsPacketParser(this)
 	, m_TsAnalyzer(this)
+	, m_TsDescrambler(this)
 	, m_TsPacketCounter(this)
 	, m_TsRecorder(this)
 	, m_TsGrabber(this)
@@ -38,8 +39,10 @@
 #endif
 
 	, m_bBuiled(false)
+	, m_bDescramble(true)
 	, m_bStartStreamingOnDriverOpen(false)
 
+	, m_bDescrambleCurServiceOnly(false)
 	, m_bWriteCurServiceOnly(false)
 	, m_WriteStream(CTsSelector::STREAM_ALL)
 
@@ -77,6 +80,8 @@
 	    ↓
 	m_TsAnalyzer
 	    ↓
+	m_TsDescrambler
+	    ↓
 	m_TsPacketCounter
 	    ↓
 	m_TsGrabber
@@ -93,7 +98,9 @@
 	// デコーダグラフ構築
 	m_BonSrcDecoder.SetOutputDecoder(&m_TsPacketParser);
 	m_TsPacketParser.SetOutputDecoder(&m_TsAnalyzer);
-	m_TsAnalyzer.SetOutputDecoder(&m_TsPacketCounter);
+	m_TsAnalyzer.SetOutputDecoder(&m_TsDescrambler);
+	m_TsDescrambler.EnableDescramble(m_bDescramble);
+	m_TsDescrambler.SetOutputDecoder(&m_TsPacketCounter);
 	m_TsPacketCounter.SetOutputDecoder(&m_TsGrabber);
 #ifdef DTVENGINE_NETWORK_SUPPORT
 	m_TsGrabber.SetOutputDecoder(&m_MediaTee);
@@ -270,6 +277,9 @@
 		TRACE(TEXT("------- Service Select -------\n"));
 		TRACE(TEXT("%d (ServiceID = %04X)\n"), m_CurServiceIndex, wServiceID);
 
+		if (m_bDescrambleCurServiceOnly)
+			SetDescrambleService(wServiceID);
+
 		m_TsPacketCounter.SetActiveServiceID(wServiceID);
 
 		if (m_bWriteCurServiceOnly)
@@ -327,6 +337,71 @@
 }
 
 
+bool CDtvEngine::OpenCasCard(CCardReader::ReaderType CardReaderType, LPCTSTR pszReaderName)
+{
+	// B-CASカードを開く
+	if (CardReaderType != CCardReader::READER_NONE) {
+		Trace(CTracer::TYPE_INFORMATION, TEXT("B-CASカードを開いています..."));
+		if (!m_TsDescrambler.OpenCasCard(CardReaderType, pszReaderName)) {
+			TCHAR szText[256];
+
+			if (m_TsDescrambler.GetLastErrorText() != NULL)
+				StdUtil::snprintf(szText, _countof(szText),
+				TEXT("B-CASカードの初期化に失敗しました。%s"),
+				m_TsDescrambler.GetLastErrorText());
+			else
+				::lstrcpy(szText, TEXT("B-CASカードの初期化に失敗しました。"));
+			SetError(0, szText,
+				TEXT("カードリーダが接続されているか、設定で有効なカードリーダが選択されているか確認してください。"),
+				m_TsDescrambler.GetLastErrorSystemMessage());
+			return false;
+		}
+	}
+	else if (m_TsDescrambler.IsCasCardOpen()) {
+		m_TsDescrambler.CloseCasCard();
+	}
+	return true;
+}
+
+
+bool CDtvEngine::CloseCasCard()
+{
+	if (m_TsDescrambler.IsCasCardOpen())
+		m_TsDescrambler.CloseCasCard();
+	return true;
+}
+
+
+bool CDtvEngine::EnableDescramble(bool bDescramble)
+{
+	if (m_bDescramble != bDescramble) {
+		m_TsDescrambler.EnableDescramble(bDescramble);
+		m_bDescramble = bDescramble;
+	}
+	return true;
+}
+
+
+bool CDtvEngine::SetDescrambleService(WORD ServiceID)
+{
+	return m_TsDescrambler.SetTargetServiceID(ServiceID);
+}
+
+
+bool CDtvEngine::SetDescrambleCurServiceOnly(bool bOnly)
+{
+	if (m_bDescrambleCurServiceOnly != bOnly) {
+		WORD ServiceID = 0;
+
+		m_bDescrambleCurServiceOnly = bOnly;
+		if (bOnly)
+			GetServiceID(&ServiceID);
+		SetDescrambleService(ServiceID);
+	}
+	return true;
+}
+
+
 bool CDtvEngine::SetWriteStream(WORD ServiceID, DWORD Stream)
 {
 	m_WriteStream = Stream;
@@ -632,6 +707,41 @@
 			return 0UL;
 		}
 	}
+	else if (pDecoder == &m_TsDescrambler) {
+		switch (dwEventID) {
+		case CTsDescrambler::EVENT_EMM_PROCESSED:
+			// EMM処理が行われた
+			if (m_pEventHandler)
+				m_pEventHandler->OnEmmProcessed(static_cast<const BYTE*>(pParam));
+			return 0UL;
+
+		case CTsDescrambler::EVENT_ECM_ERROR:
+			// ECM処理でエラーが発生した
+			if (m_pEventHandler) {
+				CTsDescrambler::EcmErrorInfo *pInfo = static_cast<CTsDescrambler::EcmErrorInfo*>(pParam);
+
+				if (m_TsDescrambler.GetEcmPIDByServiceID(m_CurServiceID) == pInfo->EcmPID)
+					m_pEventHandler->OnEcmError(pInfo->pszText);
+			}
+			return 0UL;
+
+		case CTsDescrambler::EVENT_ECM_REFUSED:
+			// ECMが受け付けられない
+			if (m_pEventHandler) {
+				CTsDescrambler::EcmErrorInfo *pInfo = static_cast<CTsDescrambler::EcmErrorInfo*>(pParam);
+
+				if (m_TsDescrambler.GetEcmPIDByServiceID(m_CurServiceID) == pInfo->EcmPID)
+					m_pEventHandler->OnEcmRefused();
+			}
+			return 0UL;
+
+		case CTsDescrambler::EVENT_CARD_READER_HUNG:
+			// カードリーダーから応答が無い
+			if (m_pEventHandler)
+				m_pEventHandler->OnCardReaderHung();
+			return 0UL;
+		}
+	}
 
 	return 0UL;
 }
diff -ruN a/TSTask/TSTask/DtvEngine.h b/TSTask/TSTask/DtvEngine.h
--- a/TSTask/TSTask/DtvEngine.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/DtvEngine.h	2015-08-12 19:35:00.000000000 +0900
@@ -9,6 +9,7 @@
 #include "../BonTsEngine/BonSrcDecoder.h"
 #include "../BonTsEngine/TsPacketParser.h"
 #include "../BonTsEngine/TsAnalyzer.h"
+#include "../BonTsEngine/TsDescrambler.h"
 #include "../BonTsEngine/TsRecorder.h"
 #include "../BonTsEngine/TsGrabber.h"
 #include "../BonTsEngine/TsSelector.h"
@@ -47,6 +48,10 @@
 		virtual void OnEventUpdated(CTsAnalyzer *pTsAnalyzer) {}
 		virtual void OnTotUpdated(CTsAnalyzer *pTsAnalyzer) {}
 		virtual void OnFileWriteError(CTsRecorder *pTsRecoder, DWORD ErrorCode) {}
+		virtual void OnEmmProcessed(const BYTE *pEmmData) {}
+		virtual void OnEcmError(LPCTSTR pszText) {}
+		virtual void OnEcmRefused() {}
+		virtual void OnCardReaderHung() {}
 	};
 
 	CDtvEngine(void);
@@ -70,6 +75,13 @@
 	bool GetServiceID(WORD *pServiceID);
 	bool SetServiceByID(const WORD ServiceID, const bool bReserve = true);
 
+	bool OpenCasCard(CCardReader::ReaderType CardReaderType, LPCTSTR pszReaderName = NULL);
+	bool CloseCasCard();
+	bool EnableDescramble(bool bDescramble);
+	bool SetDescrambleService(WORD ServiceID);
+	bool SetDescrambleCurServiceOnly(bool bOnly);
+	bool GetDescrambleCurServiceOnly() const { return m_bDescrambleCurServiceOnly; }
+
 	bool SetWriteStream(WORD ServiceID, DWORD Stream = CTsSelector::STREAM_ALL);
 	bool GetWriteStream(WORD *pServiceID, DWORD *pStream = NULL);
 	bool SetWriteCurServiceOnly(bool bOnly, DWORD Stream = CTsSelector::STREAM_ALL);
@@ -97,6 +109,7 @@
 	CBonSrcDecoder m_BonSrcDecoder;
 	CTsPacketParser m_TsPacketParser;
 	CTsAnalyzer m_TsAnalyzer;
+	CTsDescrambler m_TsDescrambler;
 	CTsPacketCounter m_TsPacketCounter;
 	CTsGrabber m_TsGrabber;
 	CTsRecorder m_TsRecorder;
@@ -127,8 +140,10 @@
 	WORD m_SetChannelServiceID;
 
 	bool m_bBuiled;
+	bool m_bDescramble;
 	bool m_bStartStreamingOnDriverOpen;
 
+	bool m_bDescrambleCurServiceOnly;
 	bool m_bWriteCurServiceOnly;
 	DWORD m_WriteStream;
 
diff -ruN a/TSTask/TSTask/EventHandler.h b/TSTask/TSTask/EventHandler.h
--- a/TSTask/TSTask/EventHandler.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/EventHandler.h	2015-08-12 19:35:00.000000000 +0900
@@ -23,6 +23,11 @@
 		virtual void OnChannelChangeFailed(DWORD Space,DWORD Channel,WORD ServiceID) {}
 		virtual bool OnServiceChange(WORD ServiceID) { return true; }
 		virtual void OnServiceChanged(WORD ServiceID) {}
+		virtual bool OnCasCardOpen(LPCWSTR pszReaderName) { return true; }
+		virtual void OnCasCardOpened(LPCWSTR pszReaderName) {}
+		virtual void OnCasCardOpenFailed(LPCWSTR pszReaderName) {}
+		virtual bool OnCasCardClose() { return true; }
+		virtual void OnCasCardClosed() {}
 		virtual bool OnRecordingStart(const RecordingSettings &Settings) { return true; }
 		virtual void OnRecordingStarted(const RecordingInfo &Info) {}
 		virtual void OnRecordingStartFailed(const RecordingSettings &Settings) {}
diff -ruN a/TSTask/TSTask/TSTask.cpp b/TSTask/TSTask/TSTask.cpp
--- a/TSTask/TSTask/TSTask.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTask.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -33,6 +33,7 @@
 
 	// CEventHandler
 		bool OnTunerOpen() override;
+		void OnTunerOpened() override;
 		bool OnRecordingStart(const RecordingSettings &Settings) override;
 		void OnRecordingStarted(const RecordingInfo &Info) override;
 		void OnRecordingStopped() override;
@@ -129,6 +130,10 @@
 
 		m_Core.Initialize();
 
+		m_Core.SetMulti2Instruction(m_CurSettings.General.GetMulti2Instruction());
+		m_Core.EnableEMMProcess(m_CurSettings.General.GetEMMProcess());
+		m_Core.SetDescramble(m_CurSettings.General.GetDescrambleType());
+
 		m_TSTaskWindow.Initialize(m_hInstance);
 
 		if (!m_TaskIdentity.Initialize(TASK_TYPE_SERVER,m_CurSettings.General.GetTaskID())) {
@@ -197,6 +202,11 @@
 			ExecuteClient();
 		}
 
+		if (m_CurSettings.General.GetDescrambleType()!=DESCRAMBLE_NO
+				|| m_CurSettings.Recording.GetDescrambleType()!=DESCRAMBLE_NO) {
+			OpenCasCard();
+		}
+
 		if (!m_CommandLine.m_BonDriverFileName.empty()) {
 			OutLog(LOG_VERBOSE,L"コマンドラインで指定された BonDriver \"%s\" をロードします。",
 				   m_CommandLine.m_BonDriverFileName.c_str());
@@ -410,6 +420,11 @@
 
 		ApplyCommandLineSettings(m_CommandLine,m_CurSettings);
 
+		m_Core.EnableEMMProcess(m_CurSettings.General.GetEMMProcess());
+		if (!m_Core.IsRecording()) {
+			m_Core.SetDescramble(m_CurSettings.General.GetDescrambleType());
+		}
+
 		if (m_Core.IsStreaming()) {
 			m_Core.SetStreamingSendSize(m_CurSettings.Streaming.GetSendSize());
 			m_Core.SetStreamingSendWait(m_CurSettings.Streaming.GetSendWait(),
@@ -431,6 +446,13 @@
 		if (CommandLine.m_ClientShowCommand>=0)
 			Settings.General.SetClientShowCommand(CommandLine.m_ClientShowCommand);
 
+		if (CommandLine.m_Descramble>=0)
+			Settings.General.SetDescrambleType(DescrambleType(CommandLine.m_Descramble));
+		if (!CommandLine.m_CardReaderName.empty())
+			Settings.General.SetCardReaderName(CommandLine.m_CardReaderName);
+		if (CommandLine.m_EMMProcess!=BOOL_DEFAULT)
+			Settings.General.SetEMMProcess(CommandLine.m_EMMProcess==BOOL_TRUE);
+
 		if (CommandLine.m_LoggingLevel>=0)
 			Settings.General.SetLoggingLevel(CGeneralSettings::LoggingLevelToType(CommandLine.m_LoggingLevel));
 		if (CommandLine.m_LogOutputToFile!=BOOL_DEFAULT)
@@ -457,6 +479,8 @@
 		}
 		if (CommandLine.m_RecordingService>=0)
 			Settings.Recording.SetServiceSelectType(ServiceSelectType(CommandLine.m_RecordingService));
+		if (CommandLine.m_RecordingDescramble>=0)
+			Settings.Recording.SetDescrambleType(DescrambleType(CommandLine.m_RecordingDescramble));
 		if (CommandLine.m_Record1Seg!=BOOL_DEFAULT)
 			Settings.Recording.SetStreamFlag(STREAM_1SEG,CommandLine.m_Record1Seg==BOOL_TRUE);
 		if (CommandLine.m_RecordingPreAllocateSize>=0) {
@@ -533,8 +557,20 @@
 		return true;
 	}
 
+	void CTSTaskApp::OnTunerOpened()
+	{
+		if ((m_CurSettings.General.GetDescrambleType()!=DESCRAMBLE_NO || m_CurSettings.Recording.GetDescrambleType()!=DESCRAMBLE_NO)
+			&& !m_Core.IsCasCardOpened()) {
+			OpenCasCard();
+		}
+	}
+
 	bool CTSTaskApp::OnRecordingStart(const RecordingSettings &Settings)
 	{
+		if (Settings.Descramble!=DESCRAMBLE_NO && !m_Core.IsCasCardOpened()) {
+			OpenCasCard();
+		}
+
 		m_Core.SetWriteBufferSize(m_CurSettings.Recording.GetWriteBufferSize());
 		m_Core.SetMaxWritePendingSize(m_CurSettings.Recording.GetMaxPendingSize());
 		m_Core.SetWritePreAllocate(m_CurSettings.Recording.GetPreAllocate()?
@@ -555,6 +591,8 @@
 		if (m_CurSettings.Recording.GetExitOnStop()) {
 			OutLog(LOG_INFO,L"録画が停止したのでプログラムを終了します。");
 			Quit();
+		} else {
+			m_Core.SetDescramble(m_CurSettings.General.GetDescrambleType());
 		}
 	}
 
diff -ruN a/TSTask/TSTask/TSTaskAppCore.cpp b/TSTask/TSTask/TSTaskAppCore.cpp
--- a/TSTask/TSTask/TSTaskAppCore.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskAppCore.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -48,6 +48,15 @@
 		return true;
 	}
 
+	bool CTSTaskAppCore::OpenCasCard()
+	{
+		String CardReaderName;
+
+		m_CurSettings.General.GetCardReaderName(&CardReaderName);
+
+		return m_Core.OpenCasCard(CardReaderName.c_str());
+	}
+
 	bool CTSTaskAppCore::FormatRecordFileName(LPCWSTR pszFormat,String *pFileName)
 	{
 		return m_Core.FormatRecordFileName(pszFormat,pFileName,
diff -ruN a/TSTask/TSTask/TSTaskAppCore.h b/TSTask/TSTask/TSTaskAppCore.h
--- a/TSTask/TSTask/TSTaskAppCore.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskAppCore.h	2015-08-12 19:35:00.000000000 +0900
@@ -28,6 +28,8 @@
 
 		bool ExecuteClient();
 
+		bool OpenCasCard();
+
 		bool FormatRecordFileName(LPCWSTR pszFormat,String *pFileName);
 
 		bool ReserveRecording(const ReserveSettings &Reserve,const RecordingSettings &RecSettings);
diff -ruN a/TSTask/TSTask/TSTaskCommandLine.cpp b/TSTask/TSTask/TSTaskCommandLine.cpp
--- a/TSTask/TSTask/TSTaskCommandLine.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskCommandLine.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -11,6 +11,9 @@
 		: m_TaskID(INVALID_TASK_ID)
 		, m_ProcessPriority(-100)
 
+		, m_Descramble(-1)
+		, m_EMMProcess(BOOL_DEFAULT)
+
 		, m_ClientShowCommand(-1)
 
 		, m_TuningSpace(-1)
@@ -25,6 +28,7 @@
 		, m_RecordingDelay(0)
 		, m_RecordingDuration(0)
 		, m_RecordingService(-1)
+		, m_RecordingDescramble(-1)
 		, m_Record1Seg(BOOL_DEFAULT)
 		, m_RecordingPreAllocateSize(-1)
 		, m_ExitOnRecordingStop(BOOL_DEFAULT)
@@ -68,6 +72,13 @@
 		else
 			Parser.GetOption(L"show",&m_ClientShowCommand);
 
+		if (Parser.HasOption(L"nd"))
+			m_Descramble=DESCRAMBLE_NO;
+		else
+			Parser.GetOption(L"descramble",&m_Descramble);
+		Parser.GetOption(L"cardreader",&m_CardReaderName);
+		Parser.GetOption(L"emm", &m_EMMProcess);
+
 		Parser.GetOption(L"chspace",&m_TuningSpace);
 		Parser.GetOption(L"ch",&m_Channel);
 		Parser.GetOption(L"rch",&m_RemoteControlKeyID);
@@ -85,6 +96,7 @@
 			m_RecordingService=SERVICE_SELECT_CURRENT;
 		else
 			Parser.GetOption(L"recservice",&m_RecordingService);
+		Parser.GetOption(L"recdescramble",&m_RecordingDescramble);
 		Parser.GetOption(L"rec1seg",&m_Record1Seg);
 		Parser.GetOption(L"recallocsize",&m_RecordingPreAllocateSize);
 		Parser.GetOption(L"recexit",&m_ExitOnRecordingStop);
diff -ruN a/TSTask/TSTask/TSTaskCommandLine.h b/TSTask/TSTask/TSTaskCommandLine.h
--- a/TSTask/TSTask/TSTaskCommandLine.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskCommandLine.h	2015-08-12 19:35:00.000000000 +0900
@@ -21,6 +21,10 @@
 
 		int m_ClientShowCommand;
 
+		int m_Descramble;
+		String m_CardReaderName;
+		BoolSettingValue m_EMMProcess;
+
 		int m_TuningSpace;
 		int m_Channel;
 		int m_RemoteControlKeyID;
@@ -35,6 +39,7 @@
 		int m_RecordingDelay;
 		int m_RecordingDuration;
 		int m_RecordingService;
+		int m_RecordingDescramble;
 		BoolSettingValue m_Record1Seg;
 		LONGLONG m_RecordingPreAllocateSize;
 		BoolSettingValue m_ExitOnRecordingStop;
diff -ruN a/TSTask/TSTask/TSTaskCore.cpp b/TSTask/TSTask/TSTaskCore.cpp
--- a/TSTask/TSTask/TSTaskCore.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskCore.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -70,6 +70,8 @@
 		CloseTuner();
 		UnloadBonDriver();
 
+		CloseCasCard();
+
 		m_DtvEngine.CloseEngine();
 
 		m_EventHandlerList.clear();
@@ -653,6 +655,141 @@
 		return true;
 	}
 
+	bool CTSTaskCore::OpenCasCard(LPCWSTR pszReaderName)
+	{
+		if (!m_fInitialized)
+			return false;
+
+		if (!CloseCasCard())
+			return false;
+
+		OutLog(LOG_INFO, L"B-CASカードを開きます。(%s)", IsStringEmpty(pszReaderName) ? L"指定なし" : pszReaderName);
+
+		CTryBlockLock Lock(m_Lock);
+		if (!Lock.TryLock(m_LockTimeout)) {
+			OutTimeoutErrorLog();
+			return false;
+		}
+
+		if (!ListUtility::Enum(m_EventHandlerList.begin(), m_EventHandlerList.end(),
+			[pszReaderName](TSTask::CEventHandler *pHandler) {
+			return pHandler->OnCasCardOpen(pszReaderName);
+		})) {
+			OutLog(LOG_INFO, L"B-CASカードオープンがキャンセルされました。");
+			return false;
+		}
+
+		if (IsStringEmpty(pszReaderName))
+			pszReaderName = nullptr;
+
+		if (!m_DtvEngine.OpenCasCard(CCardReader::READER_SCARD, pszReaderName)) {
+			OutBonTsEngineErrorLog(m_DtvEngine);
+
+			for (auto e:m_EventHandlerList)
+				e->OnCasCardOpenFailed(pszReaderName);
+
+			return false;
+		}
+
+		LPCWSTR pszName = m_DtvEngine.m_TsDescrambler.GetCardReaderName();
+		if (pszName != nullptr) {
+			WCHAR szCardID[32];
+
+			m_DtvEngine.m_TsDescrambler.FormatCasCardID(szCardID, _countof(szCardID));
+			OutLog(LOG_INFO, L"カードリーダー(%s)をオープンしました。(カードID %s / メーカー識別 %c / バージョン %d)",
+				pszName,
+				szCardID,
+				m_DtvEngine.m_TsDescrambler.GetCasCardManufacturerID(),
+				m_DtvEngine.m_TsDescrambler.GetCasCardVersion());
+		}
+
+		OutLog(LOG_VERBOSE, L"B-CASカードが開かれたことを通知します。");
+
+		for (auto e:m_EventHandlerList)
+			e->OnCasCardOpened(pszReaderName);
+
+		return true;
+	}
+
+	bool CTSTaskCore::CloseCasCard()
+	{
+		if (!IsCasCardOpened())
+			return true;
+
+		OutLog(LOG_INFO, L"B-CASカードを閉じます。");
+
+		CTryBlockLock Lock(m_Lock);
+		if (!Lock.TryLock(m_LockTimeout)) {
+			OutTimeoutErrorLog();
+			return false;
+		}
+
+		if (!ListUtility::Enum(m_EventHandlerList.begin(), m_EventHandlerList.end(),
+			[](TSTask::CEventHandler *pHandler) { return pHandler->OnCasCardClose(); })) {
+			OutLog(LOG_INFO, L"B-CASカードクローズがキャンセルされました。");
+			return false;
+		}
+
+		if (!m_DtvEngine.CloseCasCard()) {
+			OutBonTsEngineErrorLog(m_DtvEngine);
+			return false;
+		}
+
+		OutLog(LOG_VERBOSE, L"B-CASカードが閉じられたことを通知します。");
+
+		for (auto e:m_EventHandlerList)
+			e->OnCasCardClosed();
+
+		return true;
+	}
+
+	bool CTSTaskCore::IsCasCardOpened() const
+	{
+		return m_DtvEngine.m_TsDescrambler.IsCasCardOpen();
+	}
+
+	bool CTSTaskCore::SetDescramble(DescrambleType Descramble)
+	{
+		OutLog(LOG_INFO, L"スクランブル解除モードを設定します。(%d)", (int)Descramble);
+
+		CTryBlockLock Lock(m_Lock);
+		if (!Lock.TryLock(m_LockTimeout)) {
+			OutTimeoutErrorLog();
+			return false;
+		}
+
+		m_DtvEngine.EnableDescramble(Descramble != DESCRAMBLE_NO);
+		m_DtvEngine.SetDescrambleCurServiceOnly(Descramble == DESCRAMBLE_CURRENT_SERVICE);
+
+		return true;
+	}
+
+	bool CTSTaskCore::SetMulti2Instruction(Multi2InstructionType Instruction)
+	{
+		if (Instruction<MULTI2_INSTRUCTION_DEFAULT || Instruction >= MULTI2_INSTRUCTION_TRAILER)
+			return false;
+
+		if (Instruction == MULTI2_INSTRUCTION_DEFAULT) {
+			if (CTsDescrambler::IsSSSE3Available())
+				Instruction = MULTI2_INSTRUCTION_SSSE3;
+			else if (CTsDescrambler::IsSSE2Available())
+				Instruction = MULTI2_INSTRUCTION_SSE2;
+			else
+				Instruction = MULTI2_INSTRUCTION_BASIC;
+		}
+
+		OutLog(LOG_INFO, L"スクランブル解除の拡張命令を設定します。(%d)", (int)Instruction);
+
+		return m_DtvEngine.m_TsDescrambler.SetInstruction(CTsDescrambler::InstructionType(Instruction));
+	}
+
+	bool CTSTaskCore::EnableEMMProcess(bool fEMMProcess)
+	{
+		OutLog(LOG_INFO, L"EMM処理を%s効にします。", fEMMProcess ? L"有" : L"無");
+
+		return m_DtvEngine.m_TsDescrambler.EnableEmmProcess(fEMMProcess);
+	}
+
 	bool CTSTaskCore::StartRecording(const RecordingSettings &Settings)
 	{
 		if (Settings.Directories.empty() || Settings.Directories.front().empty()
@@ -1130,6 +1267,7 @@
 
 		m_DtvEngine.m_TsPacketParser.ResetErrorPacketCount();
 		m_DtvEngine.m_TsPacketCounter.ResetScrambledPacketCount();
+		m_DtvEngine.m_TsDescrambler.ResetScramblePacketCount();
 
 		for (auto e:m_EventHandlerList)
 			e->OnErrorStatisticsReset();
@@ -1666,6 +1804,27 @@
 		SetNextRecordingDirectory();
 	}
 
+	void CTSTaskCore::OnEmmProcessed(const BYTE *pEmmData)
+	{
+		if (pEmmData != nullptr)
+			OutLog(LOG_INFO, L"EMM処理を行いました。");
+	}
+
+	void CTSTaskCore::OnEcmError(LPCTSTR pszText)
+	{
+		OutLog(LOG_ERROR, L"ECM処理でエラーが発生しました。(%s)", IsStringEmpty(pszText) ? L"?" : pszText);
+	}
+
+	void CTSTaskCore::OnEcmRefused()
+	{
+		OutLog(LOG_WARNING, L"契約されていないためスクランブル解除できません。");
+	}
+
+	void CTSTaskCore::OnCardReaderHung()
+	{
+		OutLog(LOG_ERROR, L"カードリーダーが応答しません。");
+	}
+
 	void CTSTaskCore::OnTrace(::CTracer::TraceType Type,LPCTSTR pszOutput)
 	{
 		if (!IsStringEmpty(pszOutput)) {
diff -ruN a/TSTask/TSTask/TSTaskCore.h b/TSTask/TSTask/TSTaskCore.h
--- a/TSTask/TSTask/TSTaskCore.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskCore.h	2015-08-12 19:35:00.000000000 +0900
@@ -40,6 +40,13 @@
 		bool GetServiceInfo(ServiceInfo *pInfo);
 		bool GetServiceList(ServiceList *pList);
 
+		bool OpenCasCard(LPCWSTR pszReaderName);
+		bool CloseCasCard();
+		bool IsCasCardOpened() const;
+		bool SetDescramble(DescrambleType Descramble);
+		bool SetMulti2Instruction(Multi2InstructionType Instruction);
+		bool EnableEMMProcess(bool fEMMProcess);
+
 		bool StartRecording(const RecordingSettings &Settings);
 		bool StopRecording();
 		bool SetNextRecordingDirectory();
@@ -93,6 +100,10 @@
 		void OnEventUpdated(::CTsAnalyzer *pTsAnalyzer) override;
 		void OnTotUpdated(::CTsAnalyzer *pTsAnalyzer) override;
 		void OnFileWriteError(::CTsRecorder *pTsRecorder,DWORD ErrorCode) override;
+		void OnEmmProcessed(const BYTE *pEmmData) override;
+		void OnEcmError(LPCTSTR pszText) override;
+		void OnEcmRefused() override;
+		void OnCardReaderHung() override;
 
 	// CTracer
 		void OnTrace(::CTracer::TraceType Type,LPCTSTR pszOutput) override;
diff -ruN a/TSTask/TSTask/TSTaskSettings.cpp b/TSTask/TSTask/TSTaskSettings.cpp
--- a/TSTask/TSTask/TSTaskSettings.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskSettings.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -29,6 +29,11 @@
 		m_ClientShowCommand=-1;
 		m_fClientExecuteOnStart=true;
 
+		m_Descramble=DESCRAMBLE_CURRENT_SERVICE;
+		m_CardReaderName.clear();
+		m_Multi2Instruction=MULTI2_INSTRUCTION_DEFAULT;
+		m_fEMMProcess=false;
+
 		m_LoggingLevel=LOG_INFO;
 		m_MaxLog=500;
 		m_fLogOutputToFile=false;
@@ -63,6 +68,13 @@
 		if (Settings.Read(L"General.StatisticsUpdateInterval",&Interval))
 			SetStatisticsUpdateInterval(Interval);
 
+		if (Settings.Read(L"General.Descramble",&Value))
+			SetDescrambleType(DescrambleType(Value));
+		Settings.Read(L"General.CardReader",&m_CardReaderName);
+		if (Settings.Read(L"General.Multi2Instruction",&Value))
+			SetMulti2Instruction(Multi2InstructionType(Value));
+		Settings.Read(L"General.EMMProcess",&m_fEMMProcess);
+
 		if (Settings.Read(L"Logging.Level",&Value))
 			SetLoggingLevel(LogType(LOG_NONE-Value));
 		Settings.Read(L"Logging.MaxCount",&m_MaxLog);
@@ -95,6 +107,11 @@
 			Settings.Write(L"General.ProcessPriority",L"");
 		Settings.Write(L"General.StatisticsUpdateInterval",m_StatisticsUpdateInterval);
 
+		Settings.Write(L"General.Descramble",(int)m_Descramble);
+		Settings.Write(L"General.CardReader",m_CardReaderName);
+		Settings.Write(L"General.Multi2Instruction",(int)m_Multi2Instruction);
+		Settings.Write(L"General.EMMProcess",m_fEMMProcess);
+
 		Settings.Write(L"Logging.Level",LOG_NONE-(int)m_LoggingLevel);
 		Settings.Write(L"Logging.MaxCount",m_MaxLog);
 		Settings.Write(L"Logging.OutputToFile",m_fLogOutputToFile);
@@ -285,6 +302,69 @@
 		return true;
 	}
 
+	DescrambleType CGeneralSettings::GetDescrambleType() const
+	{
+		return m_Descramble;
+	}
+
+	bool CGeneralSettings::SetDescrambleType(DescrambleType Type)
+	{
+		if (Type<0 || Type>=TSTask::DESCRAMBLE_TRAILER)
+			return false;
+
+		m_Descramble=Type;
+
+		return true;
+	}
+
+	bool CGeneralSettings::GetCardReaderName(String *pName) const
+	{
+		if (pName==nullptr)
+			return false;
+
+		CRWLockRead Lock(*m_pLock);
+
+		*pName=m_CardReaderName;
+
+		return true;
+	}
+
+	bool CGeneralSettings::SetCardReaderName(const String &Name)
+	{
+		CRWLockRead Lock(*m_pLock);
+
+		m_CardReaderName=Name;
+
+		return true;
+	}
+
+	Multi2InstructionType CGeneralSettings::GetMulti2Instruction() const
+	{
+		return m_Multi2Instruction;
+	}
+
+	bool CGeneralSettings::SetMulti2Instruction(Multi2InstructionType Instruction)
+	{
+		if (Instruction<MULTI2_INSTRUCTION_DEFAULT || Instruction>=MULTI2_INSTRUCTION_TRAILER)
+			return false;
+
+		m_Multi2Instruction=Instruction;
+
+		return true;
+	}
+
+	bool CGeneralSettings::GetEMMProcess() const
+	{
+		return m_fEMMProcess;
+	}
+
+	bool CGeneralSettings::SetEMMProcess(bool fEMMProcess)
+	{
+		m_fEMMProcess=fEMMProcess;
+
+		return true;
+	}
+
 	bool CGeneralSettings::SetLoggingLevel(LogType Level)
 	{
 		if (Level<0 || Level>LOG_NONE)
@@ -508,6 +588,7 @@
 		m_MinFreeSpace=100*1024*1024;
 
 		m_ServiceSelect=SERVICE_SELECT_ALL;
+		m_Descramble=DESCRAMBLE_CURRENT_SERVICE;
 		m_Streams=STREAM_ALL;
 
 		m_fSystemRequired=true;
@@ -545,6 +626,8 @@
 			m_MinFreeSpace=Size;
 		if (Settings.Read(L"Recording.Service",&Value))
 			SetServiceSelectType(ServiceSelectType(Value));
+		if (Settings.Read(L"Recording.Descramble",&Value))
+			SetDescrambleType(DescrambleType(Value));
 		bool f;
 		if (Settings.Read(L"Recording.SaveCaption",&f))
 			SetStreamFlagImpl(STREAM_CAPTION,f);
@@ -590,6 +673,7 @@
 		}
 		Settings.Write(L"Recording.MinFreeSpace",(LONGLONG)m_MinFreeSpace);
 		Settings.Write(L"Recording.Service",(int)m_ServiceSelect);
+		Settings.Write(L"Recording.Descramble",(int)m_Descramble);
 		Settings.Write(L"Recording.SaveCaption",(m_Streams&STREAM_CAPTION)!=0);
 		Settings.Write(L"Recording.SaveDataCarrousel",(m_Streams&STREAM_DATA_CARROUSEL)!=0);
 		Settings.Write(L"Recording.1SegOnly",(m_Streams&STREAM_1SEG)!=0);
@@ -713,6 +797,21 @@
 		return true;
 	}
 
+	DescrambleType CRecordingSettings::GetDescrambleType() const
+	{
+		return m_Descramble;
+	}
+
+	bool CRecordingSettings::SetDescrambleType(DescrambleType Type)
+	{
+		if (Type<0 || Type>=TSTask::DESCRAMBLE_TRAILER)
+			return false;
+
+		m_Descramble=Type;
+
+		return true;
+	}
+
 	DWORD CRecordingSettings::GetStreams() const
 	{
 		return m_Streams;
@@ -759,6 +858,7 @@
 		for (const auto &e:m_DirectoryList)
 			pSettings->Directories.push_back(e);
 		pSettings->ServiceSelect=m_ServiceSelect;
+		pSettings->Descramble=m_Descramble;
 		pSettings->Streams=m_Streams;
 
 		return true;
diff -ruN a/TSTask/TSTask/TSTaskSettings.h b/TSTask/TSTask/TSTaskSettings.h
--- a/TSTask/TSTask/TSTaskSettings.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTask/TSTaskSettings.h	2015-08-12 19:35:00.000000000 +0900
@@ -48,6 +48,15 @@
 		unsigned int GetStatisticsUpdateInterval() const;
 		bool SetStatisticsUpdateInterval(unsigned int Interval);
 
+		DescrambleType GetDescrambleType() const;
+		bool SetDescrambleType(DescrambleType Type);
+		bool GetCardReaderName(String *pName) const;
+		bool SetCardReaderName(const String &Name);
+		Multi2InstructionType GetMulti2Instruction() const;
+		bool SetMulti2Instruction(Multi2InstructionType Instruction);
+		bool GetEMMProcess() const;
+		bool SetEMMProcess(bool fEMMProcess);
+
 		bool SetLoggingLevel(LogType Level);
 		LogType GetLoggingLevel() const;
 		static LogType LoggingLevelToType(int Level) { return LogType(LOG_NONE-Level); }
@@ -75,6 +84,11 @@
 		ProcessPriority m_ProcessPriority;
 		unsigned int m_StatisticsUpdateInterval;
 
+		DescrambleType m_Descramble;
+		String m_CardReaderName;
+		Multi2InstructionType m_Multi2Instruction;
+		bool m_fEMMProcess;
+
 		LogType m_LoggingLevel;
 		unsigned int m_MaxLog;
 		bool m_fLogOutputToFile;
@@ -138,6 +152,8 @@
 		bool SetMinFreeSpace(ULONGLONG Size);
 		ServiceSelectType GetServiceSelectType() const;
 		bool SetServiceSelectType(ServiceSelectType Type);
+		DescrambleType GetDescrambleType() const;
+		bool SetDescrambleType(DescrambleType Type);
 		DWORD GetStreams() const;
 		bool SetStreams(DWORD Streams);
 		bool SetStreamFlag(DWORD Flag,bool fSet=true);
@@ -169,6 +185,7 @@
 		std::vector<String> m_DirectoryList;
 		ULONGLONG m_MinFreeSpace;
 		ServiceSelectType m_ServiceSelect;
+		DescrambleType m_Descramble;
 		DWORD m_Streams;
 
 		bool m_fSystemRequired;
diff -ruN a/TSTask/TSTaskCentre/MainBoard.cpp b/TSTask/TSTaskCentre/MainBoard.cpp
--- a/TSTask/TSTaskCentre/MainBoard.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTaskCentre/MainBoard.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -27,6 +27,8 @@
 		WM_APP_TUNER_CLOSED,
 		WM_APP_CHANNEL_CHANGED,
 		WM_APP_SERVICE_CHANGED,
+		WM_APP_CAS_CARD_OPENED,
+		WM_APP_CAS_CARD_CLOSED,
 		WM_APP_RECORDING_STARTED,
 		WM_APP_RECORDING_STOPPED,
 		WM_APP_RECORDING_FILE_CHANGED,
@@ -590,6 +592,16 @@
 		return PostMessage(WM_APP_SERVICE_CHANGED,ID,0);
 	}
 
+	bool CMainBoard::NotifyCasCardOpened(TSTask::TaskID ID)
+	{
+		return PostMessage(WM_APP_CAS_CARD_OPENED,ID,0);
+	}
+
+	bool CMainBoard::NotifyCasCardClosed(TSTask::TaskID ID)
+	{
+		return PostMessage(WM_APP_CAS_CARD_CLOSED,ID,0);
+	}
+
 	bool CMainBoard::NotifyRecordingStarted(TSTask::TaskID ID)
 	{
 		return PostMessage(WM_APP_RECORDING_STARTED,ID,0);
@@ -885,6 +897,16 @@
 			m_Core.ExecuteTaskToolOnEvent(TSTask::TaskID(wParam),TSTask::MESSAGE_EVENT_ServiceChanged);
 			return 0;
 
+		case WM_APP_CAS_CARD_OPENED:
+			TRACE(L"WM_APP_CAS_CARD_OPENED(%Iu)\n",wParam);
+			m_Core.ExecuteTaskToolOnEvent(TSTask::TaskID(wParam),TSTask::MESSAGE_EVENT_CasCardOpened);
+			return 0;
+
+		case WM_APP_CAS_CARD_CLOSED:
+			TRACE(L"WM_APP_CAS_CARD_CLOSED(%Iu)\n",wParam);
+			m_Core.ExecuteTaskToolOnEvent(TSTask::TaskID(wParam),TSTask::MESSAGE_EVENT_CasCardClosed);
+			return 0;
+
 		case WM_APP_RECORDING_STARTED:
 			TRACE(L"WM_APP_RECORDING_STARTED(%Iu)\n",wParam);
 			UpdateRecordingStatus(TSTask::TaskID(wParam));
diff -ruN a/TSTask/TSTaskCentre/MainBoard.h b/TSTask/TSTaskCentre/MainBoard.h
--- a/TSTask/TSTaskCentre/MainBoard.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTaskCentre/MainBoard.h	2015-08-12 19:35:00.000000000 +0900
@@ -143,6 +143,8 @@
 		bool NotifyTunerClosed(TSTask::TaskID ID);
 		bool NotifyChannelChanged(TSTask::TaskID ID);
 		bool NotifyServiceChanged(TSTask::TaskID ID);
+		bool NotifyCasCardOpened(TSTask::TaskID ID);
+		bool NotifyCasCardClosed(TSTask::TaskID ID);
 		bool NotifyRecordingStarted(TSTask::TaskID ID);
 		bool NotifyRecordingStopped(TSTask::TaskID ID);
 		bool NotifyRecordingFileChanged(TSTask::TaskID ID);
diff -ruN a/TSTask/TSTaskCentre/TSTaskCentre.cpp b/TSTask/TSTaskCentre/TSTaskCentre.cpp
--- a/TSTask/TSTaskCentre/TSTaskCentre.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTaskCentre/TSTaskCentre.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -31,6 +31,8 @@
 		bool OnTunerClosed(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
 		bool OnChannelChanged(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
 		bool OnServiceChanged(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
+		bool OnCasCardOpened(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
+		bool OnCasCardClosed(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
 		bool OnRecordingStarted(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
 		bool OnRecordingStopped(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
 		bool OnRecordingFileChanged(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse);
@@ -140,6 +142,8 @@
 			{TSTask::MESSAGE_EVENT_TunerClosed,				&CTSTaskCentreApp::OnTunerClosed},
 			{TSTask::MESSAGE_EVENT_ChannelChanged,			&CTSTaskCentreApp::OnChannelChanged},
 			{TSTask::MESSAGE_EVENT_ServiceChanged,			&CTSTaskCentreApp::OnServiceChanged},
+			{TSTask::MESSAGE_EVENT_CasCardOpened,			&CTSTaskCentreApp::OnCasCardOpened},
+			{TSTask::MESSAGE_EVENT_CasCardClosed,			&CTSTaskCentreApp::OnCasCardClosed},
 			{TSTask::MESSAGE_EVENT_RecordingStarted,		&CTSTaskCentreApp::OnRecordingStarted},
 			{TSTask::MESSAGE_EVENT_RecordingStopped,		&CTSTaskCentreApp::OnRecordingStopped},
 			{TSTask::MESSAGE_EVENT_RecordingFileChanged,	&CTSTaskCentreApp::OnRecordingFileChanged},
@@ -434,6 +438,46 @@
 		return true;
 	}
 
+	bool CTSTaskCentreApp::OnCasCardOpened(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse)
+	{
+		TSTask::CMessageProperty::IntType Value;
+
+		if (!pMessage->GetProperty(TSTask::MESSAGE_PROPERTY_TaskID,&Value)) {
+			pResponse->SetProperty(TSTask::MESSAGE_PROPERTY_Result,TSTask::MESSAGE_RESULT_NoProperty);
+			return true;
+		}
+
+		TSTask::TaskID TaskID=(TSTask::TaskID)Value;
+
+		TSTask::OutLog(TSTask::LOG_VERBOSE,L"タスク(%u)のB-CASカードオープン通知を受信しました。",TaskID);
+
+		m_MainBoard.NotifyCasCardOpened(TaskID);
+
+		pResponse->SetProperty(TSTask::MESSAGE_PROPERTY_Result,TSTask::MESSAGE_RESULT_OK);
+
+		return true;
+	}
+
+	bool CTSTaskCentreApp::OnCasCardClosed(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse)
+	{
+		TSTask::CMessageProperty::IntType Value;
+
+		if (!pMessage->GetProperty(TSTask::MESSAGE_PROPERTY_TaskID,&Value)) {
+			pResponse->SetProperty(TSTask::MESSAGE_PROPERTY_Result,TSTask::MESSAGE_RESULT_NoProperty);
+			return true;
+		}
+
+		TSTask::TaskID TaskID=(TSTask::TaskID)Value;
+
+		TSTask::OutLog(TSTask::LOG_VERBOSE,L"タスク(%u)のB-CASカードクローズ通知を受信しました。",TaskID);
+
+		m_MainBoard.NotifyCasCardClosed(TaskID);
+
+		pResponse->SetProperty(TSTask::MESSAGE_PROPERTY_Result,TSTask::MESSAGE_RESULT_OK);
+
+		return true;
+	}
+
 	bool CTSTaskCentreApp::OnRecordingStarted(TSTask::CMessageServer *pServer,const TSTask::CMessage *pMessage,TSTask::CMessage *pResponse)
 	{
 		TSTask::CMessageProperty::IntType Value;
diff -ruN a/TSTask/TSTaskCentre/TSTaskManager.cpp b/TSTask/TSTaskCentre/TSTaskManager.cpp
--- a/TSTask/TSTaskCentre/TSTaskManager.cpp	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTaskCentre/TSTaskManager.cpp	2015-08-12 19:35:00.000000000 +0900
@@ -583,6 +583,21 @@
 		return true;
 	}
 
+	bool CTSTaskManager::OpenCasCard(TSTask::TaskID ID,LPCWSTR pszReaderName)
+	{
+		TSTask::CMessage Message;
+
+		if (!TSTask::IsStringEmpty(pszReaderName))
+			Message.SetProperty(TSTask::MESSAGE_PROPERTY_Name,pszReaderName);
+
+		return SendBasicMessage(ID,Message);
+	}
+
+	bool CTSTaskManager::CloseCasCard(TSTask::TaskID ID)
+	{
+		return SendBasicMessage(ID,TSTask::MESSAGE_CloseCasCard);
+	}
+
 	bool CTSTaskManager::StartRecording(TSTask::TaskID ID,const TSTask::RecordingSettings *pSettings)
 	{
 		TSTask::CMessage Message(TSTask::MESSAGE_StartRecording);
diff -ruN a/TSTask/TSTaskCentre/TSTaskManager.h b/TSTask/TSTaskCentre/TSTaskManager.h
--- a/TSTask/TSTaskCentre/TSTaskManager.h	2015-08-08 23:16:06.000000000 +0900
+++ b/TSTask/TSTaskCentre/TSTaskManager.h	2015-08-12 19:35:00.000000000 +0900
@@ -77,6 +77,8 @@
 		bool SetService(TSTask::TaskID ID,WORD ServiceID);
 		bool GetService(TSTask::TaskID ID,TSTask::ServiceInfo *pInfo);
 		bool GetServiceList(TSTask::TaskID ID,TSTask::ServiceList *pList);
+		bool OpenCasCard(TSTask::TaskID ID,LPCWSTR pszReaderName);
+		bool CloseCasCard(TSTask::TaskID ID);
 		bool StartRecording(TSTask::TaskID ID,const TSTask::RecordingSettings *pSettings=nullptr);
 		bool StopRecording(TSTask::TaskID ID);
 		bool ChangeRecordingFile(TSTask::TaskID ID,LPCWSTR pszFileName);
